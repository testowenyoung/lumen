{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2018-07-17-unit-testing-nodejs-serverless-jest/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"e07735de-601d-58c2-8a15-fc74aafc2b7e","excerpt":"Have you recently found yourself wondering how to write unit tests for your Serverless project? Well, good news. I‚Äôm here to talk about just that. As the size‚Ä¶","html":"<p>Have you recently found yourself wondering how to write unit tests for your Serverless project? Well, good news. I‚Äôm here to talk about just that.</p>\n<p>As the size and complexity of your Serverless project grows, automated testing becomes the key to creating clean abstractions, getting fast feedback, and maintaining the sanity of your team.</p>\n<p>In this post, we will cover the basics of creating unit tests for Node.js projects using the <a href=\"https://serverless.com/framework/\">Serverless Framework</a>. We will also show you how to run those tests on CI and provide some tips on writing good unit tests for your Serverless project.</p>\n<p><strong>Note:</strong> The example project is available on GitHub <a href=\"https://github.com/chief-wizard/serverless-jest-example\">here</a>. We‚Äôll also cover some resources to check out for next steps at the <a href=\"#resources\">bottom of the post</a>.</p>\n<p>Ready? Let‚Äôs go.</p>\n<h2>Choosing your test framework</h2>\n<p>I‚Äôm a huge Jest fan when it comes to testing frameworks. Why?</p>\n<ol>\n<li>there‚Äôs zero configuration needed to get started</li>\n<li>it includes a good test runner</li>\n<li>has built-in functionality for mocks, stubs, and spies</li>\n<li>and has built-in code coverage reporting</li>\n</ol>\n<p>To add Jest to your project, run <code class=\"language-text\">yarn add --dev jest</code>, and you should be good to go.</p>\n<h2>Setting up the project</h2>\n<p>We decided to start with a fresh copy of the <a href=\"https://github.com/serverless/examples/tree/master/aws-node-simple-http-endpoint\"><code class=\"language-text\">aws-node-simple-http-endpoint</code></a> example in this section:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sls install -u https://github.com/serverless/examples/tree/master/aws-node-simple-http-endpoint</code></pre></div>\n<p>The default endpoint in that example is quite simple, which is great for our case:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># handler.js\n&#39;use strict&#39;;\n\nmodule.exports.endpoint = (event, context, callback) =&gt; {\n  const response = {\n    statusCode: 200,\n    body: JSON.stringify({\n      message: `Hello, the current time is ${new Date().toTimeString()}.`,\n    }),\n  };\n\n  callback(null, response);\n};</code></pre></div>\n<p>We decided that we want it to say hello to the requester in a different language every time, so we added two functions that would generate a localized greeting:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># handler.js\nfunction getLocalGreeting(language) {\n  switch(language) {\n    case &quot;en&quot;:\n      return &quot;Hello!&quot;;\n    case &quot;es&quot;:\n      return &quot;¬°Hola!&quot;;\n    case &quot;ru&quot;:\n      return &quot;–ü—Ä–∏–≤–µ—Ç!&quot;;\n    default:\n      return &quot;üëã&quot;;\n  }\n}\n\nfunction pickLocale() {\n  const languages = [&quot;en&quot;, &quot;es&quot;, &quot;cn&quot;, &quot;fr&quot;, &quot;ru&quot;];\n  # We miss Python&#39;s random.choice\n  return languages [Math.floor(Math.random() * languages.length)];\n}</code></pre></div>\n<p>We then changed the main handler slightly to make use of these two functions:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># handler.js\nmodule.exports.endpoint = (event, context, callback) =&gt; {\n  const response = {\n    statusCode: 200,\n    body: JSON.stringify({\n      message: getLocalGreeting(pickLocale()),\n    }),\n  };\n\n  callback(null, response);\n};</code></pre></div>\n<p>And then tested the function locally:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ sls invoke local -f localGreeting\n{\n    &quot;statusCode&quot;: 200,\n    &quot;body&quot;: &quot;{\\&quot;message\\&quot;:\\&quot;–ü—Ä–∏–≤–µ—Ç!\\&quot;}&quot;\n}</code></pre></div>\n<h2>Creating tests</h2>\n<p>To make sure that our local greeting generation is working as expected, we decided to create a Jest unit test for the <code class=\"language-text\">getLocalGreeting</code> function.</p>\n<p>For your tests to be picked up by Jest automatically, they either need to be placed in the <code class=\"language-text\">__tests__</code> directory of your project, or include the word <code class=\"language-text\">test</code> or <code class=\"language-text\">spec</code> in the filename. This <a href=\"http://jestjs.io/docs/en/configuration#testregex-string\">can be configured easily</a> in Jest options if you prefer a different layout.</p>\n<p>Let‚Äôs go ahead and creat the <code class=\"language-text\">__tests__</code> directory and add a <code class=\"language-text\">handler.test.js</code> file in it. The overall structure looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">.\n‚îú‚îÄ‚îÄ README.md\n‚îú‚îÄ‚îÄ __tests__\n‚îÇ   ‚îî‚îÄ‚îÄ handler.test.js\n‚îú‚îÄ‚îÄ handler.js\n‚îú‚îÄ‚îÄ node_modules\n‚îú‚îÄ‚îÄ package-lock.json\n‚îú‚îÄ‚îÄ package.json\n‚îú‚îÄ‚îÄ serverless.yml\n‚îî‚îÄ‚îÄ yarn.lock</code></pre></div>\n<p>To be able to reference functions from <code class=\"language-text\">handler.js</code> in the test file, we need to export the function we‚Äôre about to test:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># handler.js\nfunction getLocalGreeting(language) {\n...\n}\nmodule.exports.getLocalGreeting = getLocalGreeting;</code></pre></div>\n<p>In the handler test file, we load the <code class=\"language-text\">handler.js</code> file and add two assertions for the local greeting function. One of those assertions is explicitly incorrect, so that we check if errors actually display correctly:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># __tests__/handler.test.js\nconst handler = require(&#39;../handler&#39;);\n\ntest(&#39;correct greeting is generated&#39;, () =&gt; {\n  expect(handler.getLocalGreeting(&quot;en&quot;)).toBe(&quot;Hello!&quot;);\n  expect(handler.getLocalGreeting(&quot;fr&quot;)).toBe(&quot;üåä&quot;);\n});</code></pre></div>\n<h2>Running tests</h2>\n<p>We can run tests for the first time by running <code class=\"language-text\">yarn run jest</code> in the root directory of the project with no parameters supplied. We should get the expected failure back:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ yarn run jest\nFAIL  __tests__/handler.test.js\n  ‚úï correct greeting is generated (13ms)\n\n  ‚óè correct greeting is generated\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: &quot;üåä&quot;\n    Received: &quot;üëã&quot;\n\n      3 | test(&#39;correct greeting is generated&#39;, () =&gt; {\n      4 |   expect(handler.getLocalGreeting(&quot;en&quot;)).toBe(&quot;Hello!&quot;);\n    &gt; 5 |   expect(handler.getLocalGreeting(&quot;fr&quot;)).toBe(&quot;üåä&quot;);\n        |                                          ^\n      6 | });\n      7 |\n\n      at Object.&lt;anonymous&gt;.test (__tests__/handler.test.js:5:42)\n\nTest Suites: 1 failed, 1 total\nTests:       1 failed, 1 total\nSnapshots:   0 total\nTime:        1.488s\nRan all test suites.</code></pre></div>\n<p>After replacing <code class=\"language-text\">üåä</code> with <code class=\"language-text\">üëã</code> in the test‚Äôs assertion, all the tests pass:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ yarn run jest\n PASS  __tests__/handler.test.js\n  ‚úì correct greeting is generated (4ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        1.168s\nRan all test suites.</code></pre></div>\n<p>Nice!</p>\n<h2>Running unit tests on CI</h2>\n<p>Getting the tests running on CI is straightforward‚Äîjust invoke <code class=\"language-text\">jest</code> the same way you would in development. On CI services, you also generally need to add extra configuration for things like installing and caching of dependencies, and execution controls.</p>\n<p>We tested our function on <a href=\"https://circleci.com/\">CircleCI</a> with the following config:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># .circleci/config.yml\nversion: 2\njobs:\n  test:\n    working_directory: ~/nodejs-serverless-jest\n    docker:\n      - image: circleci/node:10\n    steps:\n      - checkout\n      - restore_cache:\n          key: yarn-v1-{{ checksum &quot;yarn.lock&quot; }}-{{ arch }}\n      - restore_cache:\n          key: node-v1-{{ checksum &quot;package.json&quot; }}-{{ arch }}\n      - run: yarn install\n      - save_cache:\n          key: yarn-v1-{{ checksum &quot;yarn.lock&quot; }}-{{ arch }}\n          paths:\n            - ~/.cache/yarn\n      - save_cache:\n          key: node-v1-{{ checksum &quot;package.json&quot; }}-{{ arch }}\n          paths:\n            - node_modules\n      - run:\n          name: Jest\n          command: |\n            mkdir -p test-results/jest\n            yarn run jest\n          environment:\n            JEST_JUNIT_OUTPUT: test-results/jest/junit.xml\n      - store_test_results:\n          path: test-results\n\nworkflows:\n  version: 2\n  unit-tests:\n    jobs:\n      - test</code></pre></div>\n<h2>Test folder layout</h2>\n<p>As more test cases get added to the project, it is important to keep a consistent file and folder structure within our <code class=\"language-text\">__tests__</code> folder. I advocate keeping the structure in the test directory as close as possible to the application file layout.</p>\n<p>If we were to extract the <code class=\"language-text\">getLocalGreeting</code> function into its own <code class=\"language-text\">greeting.js</code> file, we would also extract the tests for it into <code class=\"language-text\">__tests__/greeting.test.js</code>. Had we decided to add folders in our project specific to models, views, or controllers, we would also make sure to place the tests accordingly:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">.\n‚îú‚îÄ‚îÄ README.md\n‚îú‚îÄ‚îÄ __tests__\n‚îÇ   ‚îî‚îÄ‚îÄ controllers\n‚îÇ   |   ‚îî‚îÄ‚îÄ localization.test.js\n‚îÇ   ‚îî‚îÄ‚îÄ models\n‚îÇ   |   ‚îî‚îÄ‚îÄ greeting.test.js\n‚îÇ   ‚îî‚îÄ‚îÄ views\n‚îú‚îÄ‚îÄ controllers\n‚îÇ   ‚îî‚îÄ‚îÄ localization.js\n‚îú‚îÄ‚îÄ handler.js\n‚îú‚îÄ‚îÄ models\n‚îÇ   ‚îî‚îÄ‚îÄ greeting.js\n‚îú‚îÄ‚îÄ node_modules\n‚îú‚îÄ‚îÄ package-lock.json\n‚îú‚îÄ‚îÄ package.json\n‚îú‚îÄ‚îÄ serverless.yml\n‚îú‚îÄ‚îÄ views\n‚îî‚îÄ‚îÄ yarn.lock</code></pre></div>\n<h2>Unit test recommendations for Serverless projects</h2>\n<p>To make sure that the unit tests for your Serverless project are adding value to your development process and not being an annoyance for your team, I recommend following the unit testing best practices.</p>\n<h3>Keep the unit tests fast and constrained</h3>\n<p>The best unit tests are the ones that cover a specific component of the system. This ensures that each individual test runs fast enough to be executed on developer machines during the development process and on CI.</p>\n<h3>Use mocking where necessary</h3>\n<p>Mocking is a powerful tool (which Jest <a href=\"http://jestjs.io/docs/en/mock-functions\">provides</a> good functionality for). For parts of your Serverless project that interact with external databases like DynamoDB or third-party systems like Stripe, I recommend mocking out the external requests to ensure that your test suite does not depend on the third-party services being available and to reduce the latency of the test runs.</p>\n<p>Keep in mind that mocking out an external API might hide the changes in that external API. Make sure to regularly validate the mocks against the recent third-party APIs if you decide to mock out important parts of the project in tests.</p>\n<h3>Unit tests are not a full test suite by themselves</h3>\n<p>Unit tests are best used as guidelines for adequate component design and to validate the correctness of individual components. In your Serverless project, however, you will likely need to check whether different components of your project work correctly together via integration tests. I‚Äôd recommend using Jest for integration testing as well.</p>\n<h2>Conclusion</h2>\n<p>Unit tests are only one part of a successful testing strategy. In addition to unit tests, writing integration tests, end-to-end tests, and performing manual validation will help you ensure the quality of your Serverless applications.</p>\n<p>In this post, we talked about why pick Jest as the unit testing framework for your Serverless projects, how to write tests, how to structure the test files and how to execute tests on CI. I hope this will help you get started with testing your Serverless projects!</p>\n<p>I‚Äôd also highly encourage you to check out the resources below, in order to learn more about Jest and other JavaScript testing frameworks. And while you‚Äôre at it, share your own testing tips <a href=\"https://forum.serverless.com/\">with the community</a>!</p>\n<p>Please drop a comment with any feedback‚ÄîI‚Äôd love to hear from you!</p>\n<h2>Resources</h2>\n<ul>\n<li><a href=\"https://github.com/chief-wizard/serverless-jest-example\">Serverless HTTP endpoint example with the Jest test</a></li>\n<li><a href=\"http://jestjs.io/docs/en/getting-started\">Jest documentation</a></li>\n<li><a href=\"https://circleci.com/docs/2.0/configuration-reference/\">CircleCI documentation reference</a></li>\n</ul>","frontmatter":{"title":"Unit testing for Node.js Serverless projects with Jest","date":"July 17, 2018","description":"Create unit tests for Node.js using the Serverless Framework, run tests on CI, and check off our list of serverless testing best practices."}}},"pageContext":{"slug":"/posts/2018-07-17-unit-testing-nodejs-serverless-jest/","previous":{"fields":{"slug":"/posts/2018-07-16-get-in-where-you-fit-in-inclusion-diversity-tech/"},"frontmatter":{"title":"Get in where you fit in: inclusion and diversity in tech"}},"next":{"fields":{"slug":"/posts/2018-07-19-2018-serverless-community-survey-huge-growth-usage/"},"frontmatter":{"title":"2018 Serverless Community Survey: huge growth in serverless usage"}}}}}