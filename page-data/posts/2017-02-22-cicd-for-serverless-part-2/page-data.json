{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2017-02-22-cicd-for-serverless-part-2/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"82a63694-dff6-5d0a-aee2-d713b1b9a3ab","excerpt":"My last post showed you how to use Mocha to automate endpoint testing for a service with multiple methods created and deployed using the Serverless Framework…","html":"<p><a href=\"https://serverless.com/blog/cicd-for-serverless-part-1/\">My last post</a> showed you how to use Mocha to automate endpoint testing for a service with multiple methods created and deployed using the Serverless Framework. It’s possible for Test-Driven Development (TDD) to be practiced in the serverless world from a command line on a developer’s local machine. But what if you have a team of developers that are constantly merging branches back into master and you want to set up automated testing and deployment using a Continuous Integration/Continuous Deployment (CICD) toolchain? Keep reading and you’ll find out!</p>\n<p>Here we’re still using the same <a href=\"https://github.com/serverless/examples\">Todo list example the folks at the Serverless Framework created</a> as our codebase. But with some variations so that it more cleanly supports automated testing and the CICD toolchain used - <a href=\"https://aws.amazon.com/codepipeline/\">AWS CodePipeline</a>.</p>\n<p><strong>At a high level the whole thing looks like this:</strong></p>\n<p><img src=\"https://s3.amazonaws.com/analyzer.fmlnerd.com/img/ServerlessCICDmed.png\" alt=\"Serverless CICD Diagram\"></p>\n<h2>Code Differences From The Original Todo</h2>\n<p>In Part 1, I neglected to get into the details of what I had to change for the original Todo codebase to get it to function more cleanly for automated testing. Let’s explore that here.</p>\n<p>First, two of the five methods in our service perform writes.  Specifically <a href=\"https://github.com/nerdguru/serverlessTodos/blob/master/src/todos/create.js\">create.js</a> and <a href=\"https://github.com/nerdguru/serverlessTodos/blob/master/src/todos/update.js\">update.js</a>. The issue with automating the testing, especially for the create, is that the original version wasn’t returning the UUID for the newly created Todo. That meant in order to verify that the write occurred correctly, testing code would have to do a list and scan for matching Todo content.</p>\n<p>The first change, then, is to return the entire JSON of the newly created Todo. For clarity, I kept the old code commented out, so the new lines 38-44 look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// create a response</span>\n<span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    statusCode<span class=\"token operator\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// PCJ: Minor change from original, return full item inserted instead of empty result</span>\n    <span class=\"token comment\">// body: JSON.stringify(result.Item),</span>\n    body<span class=\"token operator\">:</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">.</span>Item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>For consistency’s sake, the same was done for the update.</p>\n<p>Next, the original code hard-coded the DynamoDB table name in every method handler and again in <code class=\"language-text\">serverless.yml</code> for the creation of that table. It’s possible to deploy multiple versions of your service on different branches with the same AWS account where one is your working copy if you use the local execution method on one while the other is based on a master branch that is executing in AWS CodePipeline. You just need to be a little more creative with the table naming mechanic.</p>\n<p>In the method handlers, in the constant set up to pass parameters to DynamoDB, you’ll see a change similar to this one found in the create handler:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> params <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// PCJ: Minor change from original, use environment variable for stage sensitive table name</span>\n    TableName<span class=\"token operator\">:</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">TABLE_NAME</span><span class=\"token punctuation\">,</span>\n    Item<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        id<span class=\"token operator\">:</span> uuid<span class=\"token punctuation\">.</span><span class=\"token function\">v1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        text<span class=\"token operator\">:</span> data<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">,</span>\n        checked<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n        createdAt<span class=\"token operator\">:</span> timestamp<span class=\"token punctuation\">,</span>\n        updatedAt<span class=\"token operator\">:</span> timestamp<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>So now, the database table name gets pulled from the <code class=\"language-text\">TABLE_NAME</code> environment variable, which is getting set in the <code class=\"language-text\">serverless.yml</code> file based on the stage defined for the deployment:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">provider</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> aws\n  <span class=\"token key atrule\">runtime</span><span class=\"token punctuation\">:</span> nodejs4.3\n  <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">TABLE_NAME</span><span class=\"token punctuation\">:</span> todos<span class=\"token punctuation\">-</span>$<span class=\"token punctuation\">{</span>opt<span class=\"token punctuation\">:</span>stage<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">:</span>provider.stage<span class=\"token punctuation\">}</span></code></pre></div>\n<p>I’m really liking the relatively new syntax for multiple <code class=\"language-text\">serverless.yml</code> variable references for a single evaluation, BTW.</p>\n<h2>Creating the CodePipeline and Explaining the AWS CodeBuild buildspec.yml file</h2>\n<p>I chose to use AWS CodePipeline since it was newly announced at AWS re:Invent in December. The <a href=\"https://github.com/nerdguru/serverlessTodos/blob/master/docs/codePipeline.md\">CodePipeline Execution readme</a> in my repo describes how you can set that up step-by-step. Future versions will automate this set up, but CodePipeline is new enough and the oAuth integration with GitHub wasn’t straight forward to script. So for now I’ve got a lot of screenshots for a manual process instead.</p>\n<p>At the center of the automation is AWS CodeBuild and its <code class=\"language-text\">buildspec.yml</code> file. In our example, that file looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0.1</span>\n<span class=\"token key atrule\">phases</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">install</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">commands</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> npm install\n      <span class=\"token punctuation\">-</span> npm install <span class=\"token punctuation\">-</span>g mocha\n      <span class=\"token punctuation\">-</span> npm install <span class=\"token punctuation\">-</span>g serverless\n  <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">commands</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> serverless deploy <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>stage cicd <span class=\"token punctuation\">|</span> tee deploy.out\n  <span class=\"token key atrule\">post_build</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">commands</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> . ./test.sh</code></pre></div>\n<p>Here we’ve defined three of the standard phases that CodeBuild supports: <em>install, build,</em> and <em>post_build</em>. From steps performed in the Local Execution from last time, the commands for each phase should look familiar. The various dependencies are set up during <em>install</em>.</p>\n<p>During <em>build</em>, the Serverless Framework command line is used to deploy our service with a stage called “cicd” that shouldn’t name clash with the default “dev” most likely used during Local Execution. The results are piped to deploy.out so that the endpoint name can be picked up by the <em>post_build</em> testing script that then runs the same Mocha tests as before.</p>\n<h2>Results and Gotchas</h2>\n<p>After you complete all the steps, you should be greeted with something similar to:</p>\n<p><img src=\"https://s3.amazonaws.com/analyzer.fmlnerd.com/img/completedPipeline.jpg\" alt=\"CodePipeline Goodness\"></p>\n<p>If you aren’t, CodeBuild provides excellent detailed logging via CloudWatch - although it takes a couple of clicks to get there. The most likely causes of failure have to do with CloudFormation failing for one reason or another. I found that when that happens, an unfortunate side effect is that you have to manually delete the CloudFormation stack and possibly the DynamoDB table.</p>\n<p>Once over that hump, though, you can simply check changes into the branch you associated with your CodePipeline and all the automation kicks in to test and deploy your service!</p>","frontmatter":{"title":"CICD for Serverless Part 2 - AWS CodePipeline Integration","date":"February 22, 2017","description":"Part 2 of 2 on how to implement a CICD workflow for a Serverless project"}}},"pageContext":{"slug":"/posts/2017-02-22-cicd-for-serverless-part-2/","previous":{"fields":{"slug":"/posts/2017-02-17-cicd-for-serverless-part-1/"},"frontmatter":{"title":"CICD for Serverless Part 1 - Mocha Endpoint Testing"}},"next":{"fields":{"slug":"/posts/2017-02-23-azure-functions-and-possibility/"},"frontmatter":{"title":"Azure Functions Support & Possibility"}}}}}