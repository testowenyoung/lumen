{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2018-11-20-building-chat-appliation-aws-appsync-serverless/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"ce14a319-7668-50a2-a774-d1e8f16c83bc","excerpt":"GraphQL gets a lot of praise for its expressiveness, for the idea of batching requests for data, and for its great development tooling. But there is an…","html":"<p>GraphQL gets a lot of praise for its expressiveness, for the idea of batching requests for data, and for its great development tooling. But there is an additional benefit that mostly goes unnoticed.</p>\n<p>Namely—many frontend GraphQL frameworks make a distinction between the data in the app state and the data on a remote server. This is what allows React apps powered by GraphQL APIs to seem so fast, even if they are moving a lot of data: the moving of data happens in the background.</p>\n<p>Users get from more responsive frontend apps, while also saving bandwidth. Developers can now model the data better, and deliver a more pleasant experience to the end user.</p>\n<p><strong>AppSync</strong>, AWS’s managed GraphQL layer, builds on the benefits of GraphQL and adds a few more cool things in its mobile and web SDKs: subscriptions, convenient authentication via Cognito Pools, and the ability to plug in directly to a bunch of AWS services for data.</p>\n<p><a href=\"https://serverless.com/aws-appsync/\">AppSync</a> can do a lot while still being a fully managed service, which works out great for Serverless applications. No more GraphQL resolvers in Lambda functions. No more hand-rolled authentication.\nIt’s the best of GraphQL with less complexity than before.</p>\n<p>In this article, we show how you can get started with <a href=\"https://serverless.com/aws-appsync/\">AWS AppSync</a> in a Serverless project, and talk about the benefits and drawbacks of using AppSync for your Serverless applications. Let’s get to it!</p>\n<h4>Building a chat app with AppSync</h4>\n<p>We broadly divided the process of getting a chat app running on Serverless with AWS AppSync into two parts: setting up the backend part of the service to fetch the data and deliver it via the GraphQL API, and creating a simple frontend to consume the API.</p>\n<h5>The backend</h5>\n<p>We start by defining how we will be using AppSync in our Serverless project. We are using the <a href=\"https://github.com/sid88in/serverless-appsync-plugin\">Serverless AppSync plugin</a> to simplify the configuration, and all we need to provide, in addition to the authentication config, is:</p>\n<ul>\n<li>A set of mapping templates that will help AppSync understand how to resolve each GraphQL you send out</li>\n<li>A GraphQL schema that describes our API</li>\n<li>A data source, in our case a DynamoDB database.</li>\n</ul>\n<p>The AppSync section in our serverless.yml looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">custom:\n  stage: dev\n  output:\n    file: ./front/src/stack.json\n  appSync:\n    name: ${self:service}-${self:custom.stage}\n# ... boring authentication details.\n    mappingTemplates:\n      # Here we show AppSync how to resolve our GraphQL queries.\n      - dataSource: Messages\n        type: Mutation\n        field: createMessage\n        request: &quot;createMessage-request-mapping-template.txt&quot;\n        response: &quot;createMessage-response-mapping-template.txt&quot;\n      - dataSource: Messages\n        type: Query\n        field: getMessages\n        request: &quot;getMessages-request-mapping-template.txt&quot;\n        response: &quot;getMessages-response-mapping-template.txt&quot;\n    schema: schema.graphql\n    dataSources:\n      # Here we describe the DynamoDB table we’ll be using as the data source.\n      - type: AMAZON_DYNAMODB\n        name: Messages\n        description: Messages Table\n        config:\n          tableName: { Ref: MessagesTable }\n          serviceRoleArn: { Fn::GetAtt: [AppSyncDynamoDBServiceRole, Arn] }\n          iamRoleStatements:\n            - Effect: &quot;Allow&quot;\n              Action:\n                - &quot;dynamodb:*&quot;\n              Resource:\n                - &quot;arn:aws:dynamodb:::table/Messages&quot;\n                - &quot;arn:aws:dynamodb:::table/Messages/*&quot;</code></pre></div>\n<p>Our mapping templates for DynamoDB are almost an identical copy of the example <a href=\"https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-dynamodb.html#aws-appsync-resolver-mapping-template-reference-dynamodb-putitem\">from the AppSync docs</a>, and allow us to get and create items in the Messages table. We place all mapping templates in the <code class=\"language-text\">mapping-templates</code> subdirectory.</p>\n<p>For our GraphQL schema, we are starting simple, with only a few actions that are strictly necessary for a useful chat app:</p>\n<ul>\n<li>A way to create a message — in this case, the createMessage mutation.</li>\n<li>A way to get all messages — the getMessages query.</li>\n<li>A subscription for all incoming messages, addMessage.</li>\n<li>A description of the fields of the Message object — in this case, we want a message ID, the text of the message, the date it was posted, and the handle of the person who posted it.</li>\n</ul>\n<p>With all those things our schema looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type Mutation {\n    createMessage(\n        body: String!\n    ): Message!\n}\n\ntype Query {\n    getMessages(filter: String): [Message!]!\n}\n\ntype Subscription {\n    addMessage: Message\n        @aws_subscribe(mutations: [&quot;createMessage&quot;])\n}\n\ntype Message {\n    messageId: String!\n    body: String!\n    createdAt: String!\n    handle: String!\n}\n\nschema {\n    query: Query\n    mutation: Mutation\n    subscription: Subscription\n}</code></pre></div>\n<p>This is all we need on the backend side to get AppSync up and running. We can now deploy the service:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ serverless deploy</code></pre></div>\n<p>And then watch all resources get created.</p>\n<h5>Frontend</h5>\n<p>On the frontend, we use the GraphQL operations and the Authentication module from <a href=\"https://github.com/aws-amplify/amplify-js\">AWS Amplify</a>. The core of the app is the <code class=\"language-text\">App.js</code> file where we configure Amplify with all our authentication settings and point it to our GraphQL endpoint.</p>\n<p>The whole user interface, in addition to the login / sign up screens provided by Amplify, consists of two components: <code class=\"language-text\">MessagesList</code> and <code class=\"language-text\">SendMessage</code>. We use <code class=\"language-text\">[react-chat-ui](https://github.com/brandonmowat/react-chat-ui)</code> for the messages list:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Components/MessagesList.js\n\nimport React from &quot;react&quot;;\nimport { ChatFeed, Message } from &quot;react-chat-ui&quot;;\n\nexport default ({ messages, username }) =&gt; (\n  &lt;ChatFeed\n    maxHeight={window.innerHeight - 80}\n    messages={messages.map(\n      msg =&gt;\n        new Message({\n          id: msg.handle === username ? 0 : msg.messageId,\n          senderName: msg.handle,\n          message: msg.body,\n        }),\n    )}\n    isTyping={false}\n    showSenderName\n    bubblesCentered={false}\n  /&gt;\n);</code></pre></div>\n<p>We then create our own Send Message box that allows us to type in it and save the contents in the component’s state:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Components/SendMessage.js\nimport React, { Component } from &quot;react&quot;;\n\nexport default class extends Component {\n  state = {\n    body: &quot;&quot;,\n  };\n\n  handleChange(name, ev) {\n    this.setState({ [name]: ev.target.value });\n  }\n\n  async submit(e) {\n    e.preventDefault();\n\n    await this.props.onCreate({ body: this.state.body });\n\n    this.message.value = &quot;&quot;;\n  }\n\n  render() {\n    return (\n      &lt;form onSubmit={e =&gt; this.submit(e)} style={{\n        ...\n      }}&gt;\n        &lt;input\n          ref={m =&gt; {\n            this.message = m;\n          }}\n          name=&quot;body&quot;\n          placeholder=&quot;body&quot;\n          onChange={e =&gt; this.handleChange(&quot;body&quot;, e)}\n          className=&quot;message-input&quot;\n          style={{\n            ...\n          }}\n        /&gt;\n      &lt;/form&gt;\n    );\n  }\n}</code></pre></div>\n<p>We then use the two components in <code class=\"language-text\">App.js</code>.\nWe use the <code class=\"language-text\">Auth</code> info that’s coming from Amplify to get the username that we need to associate each sent message with. The <code class=\"language-text\">getMessages</code> subscription that we defined before plugs into the <code class=\"language-text\">MessagesList</code> component neatly, and the <code class=\"language-text\">submit</code> action from the <code class=\"language-text\">SendMessage</code> component triggers a GraphQL mutation that sends the message to the backend:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class App extends Component {\n  async componentDidMount() {\n    const { username } = await Auth.currentAuthenticatedUser();\n\n    this.setState({\n      username,\n    });\n  }\n\n  render() {\n    return (\n      &lt;div\n        style={{\n          ...\n        }}\n      &gt;\n        &lt;Connect\n          query={graphqlOperation(queries.getMessages)}\n          subscription={graphqlOperation(subscriptions.addMessage)}\n          onSubscriptionMsg={(prev, data) =&gt; ({\n            getMessages: [...prev.getMessages, data.addMessage],\n          })}\n        &gt;\n          {({ data: { getMessages }, loading, error }) =&gt; {\n            if (error) return &lt;h3&gt;Error&lt;/h3&gt;;\n            if (loading || !getMessages) return &lt;h3&gt;Loading...&lt;/h3&gt;;\n\n            return (\n              &lt;MessagesList\n                messages={getMessages}\n                username={this.state.username}\n              /&gt;\n            );\n          }}\n        &lt;/Connect&gt;\n\n        &lt;Connect\n          mutation={graphqlOperation(mutations.createMessage)}\n        &gt;\n          {({ mutation }) =&gt; &lt;SendMessage onCreate={mutation} /&gt;}\n        &lt;/Connect&gt;\n      &lt;/div&gt;\n    );\n  }\n}</code></pre></div>\n<p>This is all for our frontend! Once we install all the dependencies we can run it via:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ yarn run</code></pre></div>\n<p>We land on the authentication screen provided by AppSync, where we can pick a username and a password. We can then sign in and see the list of messages, send some messages, and get responses from other users:</p>\n<img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/appsync/serverless-appsync-login.gif\">\n<img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/appsync/serverless-appsync-chat.gif\">\n<h4>Ready for production?</h4>\n<p>Getting started with AppSync takes very little time compared to creating and deploying your own GraphQL service, building authentication for it, and adding new API functionality.\nThe simplicity of AppSync, as it is generally the case for managed services, comes with a few limitations.</p>\n<h5>Data sources</h5>\n<p>In the chat app, we are using the <a href=\"https://serverless.com/dynamodb/\">DynamoDB</a> data source, which is one of the better-supported sources in AppSync. Another fully-managed data source that’s available out of the box is the Amazon Elasticsearch Service.</p>\n<p>AWS Lambda is the third data source option supported by AppSync. You could create a service in AWS Lambda that would query an RDS database, or go to an HTTP service outside of AWS to get the data. While this allows for some extensibility, doing anything with Lambda would require more work than just using a fully managed service like in our DynamoDB example above.</p>\n<p>Finally, you can use <a href=\"https://docs.aws.amazon.com/appsync/latest/devguide/tutorial-rds-resolvers.html\">Aurora Serverless</a> as a data source for your resolvers as well. Aurora Serverless is a fully-managed relational database with on-demand scale-up and scale-down. Aurora Serverless has versions compatible with MySQL or PostgreSQL, so they work well with existing tooling. While it’s still early for Serverless Aurora, I’m <a href=\"https://serverless.com/blog/serverless-aurora-future-of-data/\">very bullish on its future in the serverless ecosystem</a>.</p>\n<h5>Authentication options</h5>\n<p>In the chat app project, we used the Cognito User Pools authentication mechanism.</p>\n<p>If that doesn’t work for you, there aren’t many other options that don’t require managing the users yourself. You can use an OpenID provider (Google and Heroku are some of the providers), but otherwise, you’ll have to come up with a user management solution yourself.</p>\n<h5>Metrics and logging</h5>\n<p>AppSync currently only supports submitting metrics to CloudWatch, and the metrics it can submit are limited to <code class=\"language-text\">4xx</code> responses, <code class=\"language-text\">5xx</code> responses and the latency of AppSync operations.</p>\n<p>If AppSync becomes part of your production service, you don’t have much granularity in the metrics or the logs if something goes wrong.</p>\n<h4>Conclusion</h4>\n<p>In this article, we went through creating a chat app with AWS AppSync and Serverless, and saw that it’s pretty easy to get started. The service isn’t necessarily ready for production, but allows for fast development and prototyping.</p>\n<p>The complete example is available <a href=\"https://github.com/chief-wizard/serverless-appsync-chat-app\">here</a>. Check out <a href=\"https://aws.amazon.com/appsync/\">AWS AppSync</a>, its <a href=\"https://docs.aws.amazon.com/appsync/latest/devguide/welcome.html\">developer guide</a>, and <a href=\"https://aws-amplify.github.io/docs/js/api\">the docs for Amplify</a>.</p>\n<p>You can find the docs for the Serverless AppSync plugin <a href=\"https://github.com/sid88in/serverless-appsync-plugin\">here</a>.</p>\n<p>The React Chat UI project is <a href=\"https://github.com/brandonmowat/react-chat-ui\">here</a>.</p>\n<h5>More on AppSync &#x26; GraphQL</h5>\n<ul>\n<li><a href=\"https://serverless.com/blog/build-geosearch-graphql-api-aws-appsync-elasticsearch\">Build a serverless GeoSearch GraphQL API using AWS AppSync &#x26; Elasticsearch</a></li>\n<li><a href=\"https://serverless.com/blog/running-scalable-reliable-graphql-endpoint-with-serverless\">Running a scalable &#x26; reliable GraphQL endpoint with Serverless</a></li>\n<li><a href=\"https://serverless.com/blog/make-serverless-graphql-api-using-lambda-dynamodb\">How to make a serverless GraphQL API using Lambda and DynamoDB</a></li>\n</ul>","frontmatter":{"title":"Building a chat application using AWS AppSync and Serverless","date":"November 19, 2018","description":"Let's build a chat app using AWS AppSync and the Serverless Framework! Plus: info on data sources, metrics and logs, and authentication."}}},"pageContext":{"slug":"/posts/2018-11-20-building-chat-appliation-aws-appsync-serverless/","previous":{"fields":{"slug":"/posts/2018-11-12-true-cost-employee-calculator/"},"frontmatter":{"title":"The true cost of a new employee: compensation calculator for startups"}},"next":{"fields":{"slug":"/posts/2018-11-26-no-server-november-reinvent-hackathon/"},"frontmatter":{"title":"The re:Invent serverless virtual hackathon begins NOW"}}}}}