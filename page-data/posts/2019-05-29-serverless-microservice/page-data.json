{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2019-05-29-serverless-microservice/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"5069879b-fb17-58bd-a3d8-7b47f1989d55","excerpt":"As more people begin deploying production web applications with Serverless it comes into question how exactly to structure an application repository that has…","html":"<p>As more people begin deploying production web applications with Serverless it comes into question how exactly to structure an application repository that has multiple components with Serverless.  Imagine you’re building an e-commerce website where you expect users to register, and those users can create an order.  These front end transactions can be handled in this example.  Lets say as part of that order, you have a backend system for fulfillment of the order such as an API request to another system. In this example, when an order is created it will trigger a message sent to a backend function to process the order.</p>\n<p>In this post, I have come armed with a repository help get you started with your Serverless application development.  With this example you get two DynamoDB tables representing a place to store your application’s data, an API Gateway that you can hook into a front end, or back end process to interface with your application and 3 separate endpoint Lambda functions, a SQS queue to simulate a message being sent to the acting backend, and the backend which is one Lambda function that is triggered from the previously mentioned SQS queue.</p>\n<p>As well as demonstrating a functioning example, this will also go over some <strong>best practices</strong> for using multiple environments, custom variables per environment, how to package functions individually, how to use IAM roles per function individually, import yaml template fragments, and exporting API Gateway RestApiId to use in other <code class=\"language-text\">serverless.yml</code> files.</p>\n<p>As well as getting you started with an application template, this design will also help you circumvent around a the <a href=\"https://serverless.com/blog/serverless-workaround-cloudformation-200-resource-limit/\">well known 200 resource limit with AWS Cloudformation.</a></p>\n<p>Another benefit of this design is you are able to deploy your API endpoints separately from your backend infrastructure, while still having them loosely dependent on each other.  Not only can you deploy the infrastructure together, but you can decouple the infrastructure and deploy individual API endpoints for development and deployment agility.</p>\n<h2>Getting Started</h2>\n<p>To get started you’ll need your environment configured with AWS credentials.\nNext, lets pull down the example repository and jump into it:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> clone https://github.com/trilom/sls-microservice.git\n<span class=\"token builtin class-name\">cd</span> sls-microservice/backend</code></pre></div>\n<h2>How to use <code class=\"language-text\">make buildAll</code> and <code class=\"language-text\">make deployAll</code></h2>\n<p>Getting started is simple, after cloning the repository all you need to do is build the project with <code class=\"language-text\">make buildAll</code> and then deploy the project with <code class=\"language-text\">make deployAll</code>.<br>\n<code class=\"language-text\">make buildAll</code> will run <code class=\"language-text\">yarn install</code> in the <code class=\"language-text\">./backend</code> directory, then it will look at each directory in the <code class=\"language-text\">./backend/src</code> directory and run <code class=\"language-text\">yarn install</code> for each, then it will run <code class=\"language-text\">make buildAll</code> from the <code class=\"language-text\">./api</code> directory.  This will look at each directory in the <code class=\"language-text\">./api/src</code> directory and run <code class=\"language-text\">yarn install</code> for each.<br>\n<code class=\"language-text\">make deployAll</code> will run <code class=\"language-text\">serverless deploy --stage dev</code> in the <code class=\"language-text\">./backend</code> directory and then it will run <code class=\"language-text\">make deployAll --STAGE=&#39;dev&#39;</code> from the <code class=\"language-text\">./api</code> directory.  This will look at each directory in the <code class=\"language-text\">./api/src</code> directory and run <code class=\"language-text\">serverless deploy --stage dev</code> for each.  </p>\n<h2>What does this build</h2>\n<img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/sls-microservice/sls-microservice.jpg\">\nThis will define an example Serverless infrastructure stack containing:\n<ol>\n<li><strong>an API Gateway</strong>\nThe API has 6 endpoints.  One to create a user, one to get a user information, one to get a list of users, one to get a list of orders for a user, one to get order information for that user, and one to create an order.</li>\n<li><strong>two DynamoDB tables</strong>\nOne is the user table and one is the order table.</li>\n<li><strong>a SQS queue</strong>\nAn SQS queue that looks out for orders and moves them to fulfillment.</li>\n<li><strong>one backend lambda function, and three api lambda functions</strong>\nThe backend function will look for messages in the Order queue, then move them to fulfillment.\nThe API functions are split into 3 endpoints where you can implement different packages scope.</li>\n</ol>\n<h2>Dev Environment</h2>\n<p>One benefit that Serverless has out of the box is support for multiple stages.  This example takes advantage of using multiple stages in order to define <strong>custom stage variables</strong>.  In the <code class=\"language-text\">./backend/serverless.yml</code> you can see the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">custom</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">prod</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">Stack</span><span class=\"token punctuation\">:</span> ExampleSite\n    <span class=\"token key atrule\">LogLevel</span><span class=\"token punctuation\">:</span> info\n    <span class=\"token key atrule\">OrdersTableRCU</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n    <span class=\"token key atrule\">OrdersTableWCU</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n    <span class=\"token key atrule\">UsersTableRCU</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n    <span class=\"token key atrule\">UsersTableWCU</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n  <span class=\"token key atrule\">dev</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">Stack</span><span class=\"token punctuation\">:</span> ExampleSite\n    <span class=\"token key atrule\">LogLevel</span><span class=\"token punctuation\">:</span> debug\n    <span class=\"token key atrule\">OrdersTableRCU</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n    <span class=\"token key atrule\">OrdersTableWCU</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n    <span class=\"token key atrule\">UsersTableRCU</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n    <span class=\"token key atrule\">UsersTableWCU</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span></code></pre></div>\n<p>This allows us to define specific parameters for different environments of our site.  In our example, we are setting a specific logging level, as well as specifically defining our table capacity.\nTo utilize this feature, lets take a look at the <code class=\"language-text\">provider</code> section:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">provider</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> aws\n  <span class=\"token key atrule\">runtime</span><span class=\"token punctuation\">:</span> nodejs10.x\n  <span class=\"token key atrule\">memorySize</span><span class=\"token punctuation\">:</span> <span class=\"token number\">128</span>\n  <span class=\"token key atrule\">timeout</span><span class=\"token punctuation\">:</span> <span class=\"token number\">10</span>\n  <span class=\"token key atrule\">region</span><span class=\"token punctuation\">:</span> us<span class=\"token punctuation\">-</span>east<span class=\"token punctuation\">-</span><span class=\"token number\">1</span>\n  <span class=\"token key atrule\">stage</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>opt<span class=\"token punctuation\">:</span>stage<span class=\"token punctuation\">,</span> <span class=\"token string\">'dev'</span><span class=\"token punctuation\">}</span>\n  <span class=\"token key atrule\">logRetentionInDays</span><span class=\"token punctuation\">:</span> <span class=\"token number\">14</span>\n  <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">logLevel</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>custom.$<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>provider.stage<span class=\"token punctuation\">}</span>.LogLevel<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Here we are taking in the option <code class=\"language-text\">stage</code> from the command line, and setting the default to <code class=\"language-text\">dev</code> with the <code class=\"language-text\">stage</code> parameter.  In the <em>environment.logLevel</em> parameter, we are importing a <strong>custom stage variable</strong> from our defined variables previously.</p>\n<h2>Package functions individually and reducing dependencies</h2>\n<p>Dependencies are something that might be challenging to manage.  I like to keep my functions below <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/limits.html\"><em>3 MB</em> whenever possible</a> to preserve console editing ability.  Some tools I use to accomplish this include packaging my functions individually, and using <code class=\"language-text\">serverless-plugin-reducer</code> to ensure I’m not uploading unnecessary dependencies.  This plugin will look at your <code class=\"language-text\">requires</code> from your code, and resolve dependencies from that and ensure only <em>lambda</em> dependencies get packaged.  Using this plugin is simple, first include it in your plugin, and ensure package individually is set to true:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">package</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">individually</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n\n<span class=\"token key atrule\">plugins</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> serverless<span class=\"token punctuation\">-</span>plugin<span class=\"token punctuation\">-</span>reducer</code></pre></div>\n<h2>Use IAM Roles individually w/ serverless-iam-roles-per-function</h2>\n<p>Serverless by default allows you to specify an iam role per <code class=\"language-text\">serverless.yml</code>, we are using the <code class=\"language-text\">serverless-iam-roles-per-function</code> plugin to add the <em>functions.iamRoleStatements</em> parameter.  With this we are able to define specific iam statements per function giving you precise security controls.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">functions</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">Orders</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">handler</span><span class=\"token punctuation\">:</span> src/orders/index.handler\n    <span class=\"token key atrule\">iamRoleStatements</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">Effect</span><span class=\"token punctuation\">:</span> Allow\n        <span class=\"token key atrule\">Action</span><span class=\"token punctuation\">:</span>\n          <span class=\"token punctuation\">-</span> dynamodb<span class=\"token punctuation\">:</span>UpdateItem\n        <span class=\"token key atrule\">Resource</span><span class=\"token punctuation\">:</span>\n          <span class=\"token punctuation\">-</span> arn<span class=\"token punctuation\">:</span>aws<span class=\"token punctuation\">:</span>dynamodb<span class=\"token punctuation\">:</span><span class=\"token comment\">#{AWS::Region}:#{AWS::AccountId}:table/${self:custom.${self:provider.stage}.Stack}-Orders-${self:provider.stage}</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">Effect</span><span class=\"token punctuation\">:</span> Allow\n        <span class=\"token key atrule\">Action</span><span class=\"token punctuation\">:</span>\n          <span class=\"token punctuation\">-</span> sqs<span class=\"token punctuation\">:</span>ReceiveMessage\n          <span class=\"token punctuation\">-</span> sqs<span class=\"token punctuation\">:</span>DeleteMessage\n          <span class=\"token punctuation\">-</span> sqs<span class=\"token punctuation\">:</span>GetQueueAttributes\n        <span class=\"token key atrule\">Resource</span><span class=\"token punctuation\">:</span>\n          <span class=\"token punctuation\">-</span> arn<span class=\"token punctuation\">:</span>aws<span class=\"token punctuation\">:</span>sqs<span class=\"token punctuation\">:</span><span class=\"token comment\">#{AWS::Region}:#{AWS::AccountId}:${self:custom.${self:provider.stage}.Stack}-OrdersQueue-${self:provider.stage}</span>\n<span class=\"token key atrule\">plugins</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> serverless<span class=\"token punctuation\">-</span>plugin<span class=\"token punctuation\">-</span>reducer</code></pre></div>\n<h2>Export API Gateway RestApi</h2>\n<p>In Serverless, when you define a function with a http event this will create an API Gateway.  In this example our <code class=\"language-text\">./backend/serverless.yml</code> defines a <code class=\"language-text\">root</code> endpoint, this endpoint is a simple health check.  We then export this API Gateway’s <em>RestApiId</em> and <em>RootResourceId</em> in order to reuse in our separate API Gateway endpoints defined in <code class=\"language-text\">./api/src</code>.</p>\n<ol>\n<li>\n<p>To demonstrate, in our <code class=\"language-text\">./backend/serverless.yml</code> we export <em>RestApiId</em> and <em>RootResourceId</em>.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">...</span></code></pre></div>\n</li>\n<li>\n<p>Outputs:\nApiGWRestApiId:\nValue:\nRef: ApiGatewayRestApi\nExport:\nName: ${self:custom.${self:provider.stage}.Stack}-restApiId-${self:provider.stage}\nApiGWRootResourceId:\nValue:\nFn::GetAtt:\n- ApiGatewayRestApi\n- RootResourceId\nExport:\nName: ${self:custom.${self:provider.stage}.Stack}-rootResourceId-${self:provider.stage}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n</li>\n<li>\n<p>We then import these <strong>export variables</strong> into for example <code class=\"language-text\">./api/src/order/serverless.yml</code> into <em>provider.apiGateway</em>.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">provider</span><span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">...</span>\n<span class=\"token key atrule\">apiGateway</span><span class=\"token punctuation\">:</span>\n<span class=\"token key atrule\">restApiId</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">'Fn::ImportValue'</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>custom.$<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>provider.stage<span class=\"token punctuation\">}</span>.Stack<span class=\"token punctuation\">}</span><span class=\"token punctuation\">-</span>restApiId<span class=\"token punctuation\">-</span>$<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>provider.stage<span class=\"token punctuation\">}</span>\n<span class=\"token key atrule\">restApiRootResourceId</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">'Fn::ImportValue'</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>custom.$<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>provider.stage<span class=\"token punctuation\">}</span>.Stack<span class=\"token punctuation\">}</span><span class=\"token punctuation\">-</span>rootResourceId<span class=\"token punctuation\">-</span>$<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>provider.stage<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">...</span></code></pre></div>\n<p>This will tell the API Gateway what <em>RestApiId</em> to use, and what the <em>RootResourceId</em> is so that it can build child endpoints from the Root Resource.</p>\n</li>\n<li>\n<p>When you are nesting a route within a route, you will need to export the parent route’s <em>ResourceId</em>.  For example, in <code class=\"language-text\">./api/src/user/serverless.yml</code> we export the parent <em>ResourceId</em> that our nested endpoint of <code class=\"language-text\">/user/{userid}/order</code> will use, which is <code class=\"language-text\">/user/{userid}</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n<span class=\"token key atrule\">Outputs</span><span class=\"token punctuation\">:</span>\n<span class=\"token key atrule\">ApiRootUserUseridVar</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">Value</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">Ref</span><span class=\"token punctuation\">:</span> ApiGatewayResourceUserUseridVar\n  <span class=\"token key atrule\">Export</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">Name</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>custom.$<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>provider.stage<span class=\"token punctuation\">}</span>.Stack<span class=\"token punctuation\">}</span><span class=\"token punctuation\">-</span>ApiRootUserUseridVar<span class=\"token punctuation\">-</span>$<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>provider.stage<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>And import the <em>ResourceId</em> into the child route defined in <code class=\"language-text\">./api/src/user/order/serverless.yml</code> as a <em>provider.apiGateway.restApiResources</em> parameter for the route.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">provider</span><span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">...</span>\n<span class=\"token key atrule\">apiGateway</span><span class=\"token punctuation\">:</span>\n<span class=\"token key atrule\">restApiId</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">'Fn::ImportValue'</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>custom.$<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>provider.stage<span class=\"token punctuation\">}</span>.Stack<span class=\"token punctuation\">}</span><span class=\"token punctuation\">-</span>restApiId<span class=\"token punctuation\">-</span>$<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>provider.stage<span class=\"token punctuation\">}</span>\n<span class=\"token key atrule\">restApiResources</span><span class=\"token punctuation\">:</span>\n  /user/<span class=\"token punctuation\">{</span>userid<span class=\"token punctuation\">}</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">'Fn::ImportValue'</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>custom.$<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>provider.stage<span class=\"token punctuation\">}</span>.Stack<span class=\"token punctuation\">}</span><span class=\"token punctuation\">-</span>ApiRootUserUseridVar<span class=\"token punctuation\">-</span>$<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>provider.stage<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ol>\n<h2>Reference pseudo parameters w/ serverless-pseudo-parameters</h2>\n<p>When implementing iam best practices, you need to specify specific <strong>Resource</strong> statements and this often requires utilizing <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/pseudo-parameter-reference.html\">Cloudformation Psuedo Parameters</a> to reference <em>AccountId</em> or <em>Region</em>.  Using the plugin <code class=\"language-text\">serverless-pseudo-parameters</code> you are able to use Cloudformation pseudo parameters nearly the same as you would in Cloudformation.  Consider the following example:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">-</span> <span class=\"token key atrule\">Effect</span><span class=\"token punctuation\">:</span> Allow\n  <span class=\"token key atrule\">Action</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> dynamodb<span class=\"token punctuation\">:</span>Query\n  <span class=\"token key atrule\">Resource</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> arn<span class=\"token punctuation\">:</span>aws<span class=\"token punctuation\">:</span>dynamodb<span class=\"token punctuation\">:</span><span class=\"token comment\">#{AWS::Region}:#{AWS::AccountId}:table/${self:custom.${self:provider.stage}.Stack}-Orders-${self:provider.stage}</span></code></pre></div>\n<p>Here we are defining a DynamoDB table and specifying the <em>Region</em> and <em>AccountId</em> using <code class=\"language-text\">#{AWS::Region}</code> and <code class=\"language-text\">#{AWS::AccountId}</code> respectively.</p>\n<h2>What to do from here?</h2>\n<ul>\n<li>In more complicated examples you would be able to use AWS Cognito in the <code class=\"language-text\">/user</code> endpoint to set up authentication.  This endpoint would be scoped for user functions around Cognito and will likely have similar imports.</li>\n<li>You could also import Stripe in a <code class=\"language-text\">/billing</code> endpoint to facilitate collection of payment information.</li>\n<li>Within the <code class=\"language-text\">/orders</code> endpoint, you can set up your DynamoDB queries for managing your order collection.</li>\n<li>You could set up CI/CD simply by adding a CodePipeline resource, and utilizing CodeBuild to pull down this repository, and run the make files.</li>\n<li>Use the <code class=\"language-text\">serverless-domain-manager</code> plug-in to enable domain functionality.  Most of this structure is laid out, you just need to provide a valid <code class=\"language-text\">ApiHostedZone</code>, <code class=\"language-text\">ApiSite</code>, and <code class=\"language-text\">ApiCert</code>.  This can be created in the AWS Console for Route53 and ACM and provided here as variables.</li>\n</ul>","frontmatter":{"title":"Deploy a scalable API and Backend with Serverless, Express, and Node.js","date":"May 29, 2019","description":"Learn how to structure a microservice application in multiple serverless.yml files for infinite scalability."}}},"pageContext":{"slug":"/posts/2019-05-29-serverless-microservice/","previous":{"fields":{"slug":"/posts/2019-05-27-lessons-learned-from-sending-millions-of-serverless-webhooks/"},"frontmatter":{"title":"Lessons Learned From Sending Millions of Serverless Webhooks"}},"next":{"fields":{"slug":"/posts/2019-05-30-serverless-local-development/"},"frontmatter":{"title":"Serverless Local Development"}}}}}