{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2017-11-02-how-test-serverless-applications/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"597038a0-3017-5ce9-b720-5716339c1ad7","excerpt":"Serverless applications are quickly gaining in complexity—testing is key. I’ve been building the Serverless Framework for 2 years now, and during that time it’s…","html":"<p>Serverless applications are quickly gaining in complexity—testing is key.</p>\n<p>I’ve been building the Serverless Framework for 2 years now, and during that time it’s been my focus to create as smooth a testing and debugging experience as possible. In this article, I’ll share some techniques that you can use with the <a href=\"https://serverless.com/framework/\">Serverless Framework</a> to test and debug your serverless application during development.</p>\n<p>I’ll focus on testing serverless functions, since this is where most of the development happens.</p>\n<h4>Unit testing</h4>\n<p>This one is a gimme. You should always start with unit tests, whether or not your codebase is serverless. Forget about Lambda, the handlers, the events—just organize your codebase in an easy-to-test structure that follows your language’s best practice.</p>\n<p>Your handler should always be a thin layer that uses modules out of your code library. If those modules are well-covered with unit tests, then testing the serverless part of your application (i.e., the handlers) will be easy during the integration tests discussed below.</p>\n<p>To demonstrate this, here’s what your handler should look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> utils <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'../utils'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">createUser</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> callback</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> user <span class=\"token operator\">=</span> utils<span class=\"token punctuation\">.</span><span class=\"token function\">CreateUser</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> avatarUrl <span class=\"token operator\">=</span> utils<span class=\"token punctuation\">.</span><span class=\"token function\">updateAvatar</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span>\n\n  <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    statusCode<span class=\"token operator\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span>\n    body<span class=\"token operator\">:</span> <span class=\"token string\">'User Created!'</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>As you can see, the handler itself doesn’t contain any core logic; it just uses modules that should be unit tested independently.</p>\n<p>Read here for our much more <a href=\"https://serverless.com/blog/unit-testing-nodejs-serverless-jest/\">in-depth guide to unit testing</a>.</p>\n<h4>Integration testing</h4>\n<p>Now that you’ve covered your codebase, it’s time to move on to your handlers with overall integration tests. Let’s see how all of those units you’ve been testing individually work together.</p>\n<p><strong>Work with stages</strong><br>\nSince you’ll be interacting with the actual infrastructure pieces in your application, you’ll need to make sure you stage your application during development.</p>\n<p>Set up a dev stage—the default when using the Serverless Framework—for all application infrastructure (databases, buckets, etc.) that your codebase will use during the integration tests.</p>\n<p><strong>Set up event mocks</strong><br>\nYou’ll also need to have some event mocks prepared for all your handlers, depending on the type of event the handler is expecting.</p>\n<p>For example, if your serverless function is subscribing to an S3 event source, make sure you have a JSON file that mocks the S3 event that AWS sends out. You can get that by trying it out yourself only once on AWS, and store it somewhere for future reference.</p>\n<p>A super simple handler would look something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> utils <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'../utils'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">resizeImage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> callback</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> event<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Deploy that, and upload a file to the bucket that this function is subscribing to. This will invoke the function with the S3 event.</p>\n<p>You can then take a peek at event shape by looking in the logs with <code class=\"language-text\">serverless logs -f resizeImage</code>. Copy the logged event object into a <code class=\"language-text\">mock.json</code> file.</p>\n<p>During development, you don’t need to go back and forth to S3 for debugging anymore, you can just invoke the function directly with that mock event using <code class=\"language-text\">serverless invoke -f resizeImage -p mock.json</code>. Your development cycle will be much faster this way.</p>\n<blockquote>\n<p><strong>Note:</strong> It’s a known issue that each event source sends out a different event structure, and there’s no central place to see what events look like without trying them out yourself. We’re working behind the scenes on solving that problem. Stay tuned!</p>\n</blockquote>\n<h5>Local Lambda invocation</h5>\n<p>Let’s test those thin handler layers and how they fit in within your codebase. You can do so by invoking your function locally, using the <code class=\"language-text\">serverless invoke local</code> command.</p>\n<p>Provide it with the function you’d like to invoke, and an accurate event mock. (…Which you’ve totally set up already, right?!)</p>\n<p>For example, let’s test a function called <code class=\"language-text\">createThumbnail</code> that is subscribing to an S3 event source. We’ll do this by putting the S3 mocked event in a <code class=\"language-text\">createThumbnail.json</code> file, and then we’ll run:</p>\n<p><code class=\"language-text\">serverless invoke local -f createThumbnail -p createThumbnail.json</code></p>\n<p>While <code class=\"language-text\">invoke local</code> doesn’t emulate Lambda 100%, you’ll still be able to find issues in your codebase quickly without having to wait for a deployment.</p>\n<h5>Using the Event Gateway</h5>\n<p>We’ve recently announced a new project called the <a href=\"https://serverless.com/event-gateway/\">Event Gateway</a> that helps manage all events happening in your serverless application. You can use the Event Gateway to locally and rapidly test your functions.</p>\n<p>We’ll need two terminal sessions for this. First, spin up the Event Gateway in your current terminal session with <code class=\"language-text\">serverless run</code>. Then, open another session and emit events with the <code class=\"language-text\">serverless emit</code> command. This will invoke any function that is subscribing to that event, and you’ll be able to see the result of all function invocations in the <code class=\"language-text\">serverless run</code> session.</p>\n<blockquote>\n<p><strong>Note:</strong> this only works for functions that are subscribed to one or more events. For other functions, you’ll need to invoke the function directly, as shown above in the Local Lambda invocation section.</p>\n</blockquote>\n<h5>Remote Lambda invocation</h5>\n<p>After testing and debugging your serverless application locally, you probably feel confident enough to deploy your application—at least to the dev stage.</p>\n<p>Keep in mind that the local environment is a bit different than the actual deployment environment: e.g., AWS Lambda limits don’t apply locally, so you’ll need to be careful to make sure you won’t hitting any of those limits on deployment.</p>\n<p>Using multiple stages is a great way to have more confidence about your tests. You can have a QA environment that is an exact replica of your production environment, since they’re running on the same infrastructure. This can ferret out hidden bugs you might miss when developing locally, such as issues with your function’s IAM permissions or limitations around Lambda.</p>\n<p>Just like local testing, you can pass a mocked event to the <code class=\"language-text\">serverless invoke</code> command to test your deployed functions. But even better, now that your functions are deployed, you have the additional option of triggering the real event.</p>\n<p>In our <code class=\"language-text\">createThumbnail</code> example above, you can actually upload a photo to the S3 bucket in the dev stage and see how the <code class=\"language-text\">createThumbnail</code> Lambda reacts to that event.</p>\n<h5>Investigating Internal Server Errors</h5>\n<p>During deployment and development, you’ll almost always be hit by the unhelpful <code class=\"language-text\">internal server error</code> from Lambda.</p>\n<p>To figure out what’s actually going on inside your code, you’ll need to check the Lambda logs. Open your terminal and run:</p>\n<p><code class=\"language-text\">serverless logs -f createThumbnails --tail</code></p>\n<p>Notice the <code class=\"language-text\">--tail</code> option. That will keep an open terminal session and listen for log events as you invoke and test your functions. Just keep going back to this terminal session whenever you get an <code class=\"language-text\">internal server error</code> as you test your function.</p>\n<p>One small trick I like to do to avoid this <code class=\"language-text\">internal server error</code>, and know exactly what’s happening on invocation response, is to wrap my entire handler code into a <code class=\"language-text\">try/catch block</code>, or a <code class=\"language-text\">.catch</code> block if it’s async).</p>\n<p>Then, instead of throwing an error directly, you can pass it in the handler callback:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">createThumbnail</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> callback</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\n <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token comment\">// your highest level code goes here...</span>\n <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p><strong>Note:</strong> this doesn’t <em>always</em> work. Sometimes, the <code class=\"language-text\">internal server error</code> is beyond an issue with the codebase. Checking the logs is always your last resort.</p>\n</blockquote>\n<h4>Recap</h4>\n<p>Test your application in the dev stage and make sure that everything is working as expected. Then, you should feel safe to deploy your application to QA or production.</p>\n<p>If you’ve resolved all the code-specific errors you find in the dev stage, it’s unlikely they’ll crop up again later. But you might still face some rare infrastructure errors (e.g., ‘maximum stack count exceeded’). Those are AWS-specific errors that sometimes you can’t avoid, and unfortunately they’re outside the Serverless Framework scope.</p>\n<p>Happy bug hunting!</p>","frontmatter":{"title":"How to Test Serverless Applications","date":"November 02, 2017","description":"Tips from the Serverless team - how we test serverless applications."}}},"pageContext":{"slug":"/posts/2017-11-02-how-test-serverless-applications/","previous":{"fields":{"slug":"/posts/2017-11-02-dave-copeland-contract-based-testing-event-driven-architectures-emit-2017/"},"frontmatter":{"title":"Dave Copeland - contract-based testing for event-driven architectures"}},"next":{"fields":{"slug":"/posts/2017-11-03-shawn-burke-building-catalyst-serverless-platform-emit-2017/"},"frontmatter":{"title":"Shawn Burke - building the Catalyst serverless platform at Uber"}}}}}