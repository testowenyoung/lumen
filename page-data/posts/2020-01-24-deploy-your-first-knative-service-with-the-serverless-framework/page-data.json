{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2020-01-24-deploy-your-first-knative-service-with-the-serverless-framework/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"a2948ce6-e235-5a8e-befd-0c935e70c3ff","excerpt":"Deploying Your First Knative Service with the Serverless Framework One of the biggest ongoing conversations that I see when talking about modern microservice…","html":"<h1>Deploying Your First Knative Service with the Serverless Framework</h1>\n<p>One of the biggest ongoing conversations that I see when talking about modern microservice architectures is people asking “Should I be running that on containers or serverless?“. Well, that’s not entirely true. In fact, it is usually more of a vehemently opinionated response about why I should be using one or the other. My favorite example of this ongoing conversation is probably Trek10’s Serverless vs. Containers Rap Battle:</p>\n<div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 56.25%; position: relative; height: 0; overflow: hidden; margin-bottom: 1.0725rem\" > <iframe src=\"https://www.youtube.com/embed/TN25-siFnS8?start=28\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen style=\" position: absolute; top: 0; left: 0; width: 100%; height: 100%; \"></iframe> </div>\n<p>The somewhat surprising conclusion (considering the format of the discussion) is that both approaches are perfectly suited to different use cases. </p>\n<h2>How Kubernetes and Serverless Make Each Other Better</h2>\n<p>We can take this a slight step further and say that both architectural patterns provide us insight on the limitations and potential improvements of the other. </p>\n<p>Kubernetes has a reputation for operational complexity that Serverless infrastructure like AWS Lambda aim to eliminate entirely. The broader community around Kubernetes is constantly innovating to create tools like Knative that address these concerns and simplify the experience for developers and operators. </p>\n<p>Serverless technologies on the other hand, have a reputation for provider-imposed limitations such as cold starts and runtime length limits. Many of these concerns are starting to be addressed or are now solved problems on some platforms.</p>\n<p>At Serverless, I think it’s safe to say we think this conversation is a legitimate one and we want to contribute to it with new tools that support the best of both worlds. Because of this, the Serverless Framework <a href=\"https://serverless.com/blog/serverless-framework-knative-integration\">now supports</a> integrating with Knative - a tool to help build serverless applications on top of Kubernetes. We think that Knative can be a logical choice for many workloads, especially those that require multi-cloud portability either due to internal or regulatory requirements.</p>\n<h2>Getting Started</h2>\n<p>There are a few prerequisite steps to getting started with the Serverless Framework Knative plugin. First, you’ll need a Kubernetes cluster with Knative installed. Because of the open source nature of Kubernetes you have a lot of different options for this. You might choose to install it on any of a plethora of cloud providers or even in your own data center. For this demo, we’ll leverage Google Cloud Platform.</p>\n<h3>Creating a Kubernetes Cluster on the Google Cloud Platform</h3>\n<p>To get your Kubernetes cluster up and running in GCP, you’ll need to create a Google Cloud Platform account.</p>\n<p><strong>Create Your GCP Account</strong></p>\n<p>Go to <a href=\"https://cloud.google.com/\">https://cloud.google.com/</a> and create an account. As of this tutorial, Google offers a $300 credit towards using GCP. I’ll try and keep you within that credit allotment and the Google default limitations but keep in mind that while Kubernetes clusters can scale up and down, they still have a minimum node count of three and will be on even when they aren’t in use. As the last step in this guide, I’ll show you how to delete your cluster.</p>\n<p><strong>Create a Project in GCP</strong></p>\n<p>After you have an account up and running, you can create a project using the Google Cloud Console <a href=\"https://console.cloud.google.com/projectcreate\">here</a>. I named mine <code class=\"language-text\">sls-kubernetes-project</code> to keep things straight:</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/2020-01-knative-tutorial/step2.png\" alt=\"Screenshot of Google Cloud Project UI\"></p>\n<p>Make sure that you keep a hold of that value whatever you name yours because we’ll be using it later.</p>\n<p><strong>Install and Configure the Google SDK</strong></p>\n<p>To create your Kubernetes cluster and interface with it you’ll need to use the Google SDK. It will provide a nice CLI interface to do everything you need. Depending on your operating system, you can get started <a href=\"https://cloud.google.com/sdk/docs/quickstarts\">here</a>.</p>\n<p>If you followed the installation instructions for the SDK you probably also authenticated it with your Google Cloud account. If not, you can do this with: <code class=\"language-text\">gcloud auth login</code></p>\n<p>When going through this process it should prompt you to select a project. Make sure to select the project you just created, <code class=\"language-text\">sls-kubernetes-project</code> in my case.</p>\n<p>After that, let’s set some environment variables to make creating our cluster a bit easier. We’ll set one for our cluster name, our cluster zone (where we’re deploying to in GCP), and our project name.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export CLUSTER_NAME=slsknative\nexport CLUSTER_ZONE=us-west1-c\nexport PROJECT=sls-kubernetes-project</code></pre></div>\n<p>I’ve used <code class=\"language-text\">slsknative</code> for my cluster name, you can use <code class=\"language-text\">knative</code> or something else that doesn’t conflict with any other clusters you might have running and follows the naming conventions for a cluster.</p>\n<p>Now make sure we set our project as the default in our Google Cloud CLI settings. You can check this with <code class=\"language-text\">gcloud config list</code>. If part of the output includes your project name in there like this you’re good to go:</p>\n<p><code class=\"language-text\">project = sls-kubernetes-project</code></p>\n<p>Otherwise, set the project config with this command after you set the $PROJECT environment variable:</p>\n<p><code class=\"language-text\">gcloud projects create $PROJECT --set-as-default</code></p>\n<p>Next, let’s enable some of the APIs for the services we’re going to use on Google Cloud:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">gcloud services enable \\\n  cloudapis.googleapis.com \\\n  container.googleapis.com \\\n  containerregistry.googleapis.com</code></pre></div>\n<p>After this command completes, we should be ready to create our Kubernetes cluster!</p>\n<p><strong>Create Your Kubernetes Cluster</strong></p>\n<p>Now for the hard part (sort of, Google makes the surprisingly easy). You’ll use the following command to create a Kubernetes cluster in Google Cloud:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">gcloud beta container clusters create $CLUSTER_NAME \\\n  --addons=HorizontalPodAutoscaling,HttpLoadBalancing,Istio \\\n  --machine-type=n1-standard-2 \\\n  --cluster-version=latest --zone=$CLUSTER_ZONE \\\n  --enable-stackdriver-kubernetes --enable-ip-alias \\\n  --enable-autoscaling --min-nodes=1 --max-nodes=10 \\\n  --enable-autorepair \\\n  --scopes cloud-platform</code></pre></div>\n<p>So, what’s this doing? Well we’re using GCP to create a new cluster and passing in some standard configuration to create a cluster that will work with Knative.</p>\n<p>First, we add some addons like Istio that work well with Knative. We also specify the machine types we want to be in our cluster. I’m using slightly smaller machine types of <code class=\"language-text\">n1-standard-2</code> because Kubernetes clusters have a minimum of three nodes and as of this demo Google Cloud limits newly-created accounts to 8 vCPUs in a single region. You can spin up a more robust cluster with larger instances, but you might end up needing to activate the account and make sure your limits are increased. </p>\n<p>You’ll notice that I also have auto-scaling enabled in this command, but in this case I might end up hitting some of those account limits if I scaled too far.</p>\n<p>After the cluster finishes creating, you’ll need to grant yourself admin permissions to administrate it. You can do that with this command:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">kubectl create clusterrolebinding cluster-admin-binding \\\n  --clusterrole=cluster-admin \\\n  --user=$(gcloud config get-value core/account)</code></pre></div>\n<p>Once you have those administrator permissions, you’ll be able to use <code class=\"language-text\">kubectl</code> to interact with the cluster and install Knative. If you’ve already installed Docker on your machine before you may see a warning about <code class=\"language-text\">kubectl</code> here or later on that looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">WARNING:   There are older versions of Google Cloud Platform tools on your system PATH.\n  Please remove the following to avoid accidentally invoking these old tools:\n\n  /Applications/Docker.app/Contents/Resources/bin/kubectl</code></pre></div>\n<p>Just make sure that you restart your terminal at this point. Likely, GCP changed your path in the installation process so you will then find <code class=\"language-text\">kubectl</code> at <code class=\"language-text\">~/google-cloud-sdk/bin/kubectl</code>. If it didn’t, just make sure you’re using the Google Cloud SDK <code class=\"language-text\">kubectl</code> installation or some other recent installation. The easiest way to verify this is to enter <code class=\"language-text\">which kubectl</code> and confirm that it references the location in the Google Cloud SDK folder.</p>\n<h3>Installing Knative on Our Cluster</h3>\n<p>So now we’re ready to install Knative on our Kubernetes cluster! First, we’ll run this command which helps avoid race conditions in the installation process:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">kubectl apply --selector knative.dev/crd-install=true \\\n--filename https://github.com/knative/serving/releases/download/v0.11.0/serving.yaml \\\n--filename https://github.com/knative/eventing/releases/download/v0.11.0/release.yaml \\\n--filename https://github.com/knative/serving/releases/download/v0.11.0/monitoring.yaml</code></pre></div>\n<p>Then we can actually complete the install with this command:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">kubectl apply \\\n--filename https://github.com/knative/serving/releases/download/v0.11.0/serving.yaml \\\n--filename https://github.com/knative/eventing/releases/download/v0.11.0/release.yaml \\\n--filename https://github.com/knative/serving/releases/download/v0.11.0/monitoring.yaml</code></pre></div>\n<p>This will get all the Knative goodies we need into our Kubernetes cluster. While it installs, we just need to wait for a few minutes and monitor the installation of the Knative components until they are all showing a running status. We do that with these three commands:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">kubectl get pods --namespace knative-serving\nkubectl get pods --namespace knative-eventing\nkubectl get pods --namespace knative-monitoring</code></pre></div>\n<p>Run them each every few minutes and then confirm that all of the results have a status of running. When that’s complete, you should have Knative up and running in Kubernetes in the Google Cloud!</p>\n<h3>Using the Serverless Framework and Knative</h3>\n<p>Now that we’ve got our cluster and Knative setup we’re ready to start using the Serverless Framework! </p>\n<p>First, make sure you have at least Node.js 8+ installed on your local machine. Then, if you still need to install the Serverless Framework run the following <code class=\"language-text\">npm</code> command to install it on your machine:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">npm install --global serverless</code></pre></div>\n<p>Next up we need to create a new Serverless Framework project with the <code class=\"language-text\">knative-docker</code> template and then change directories into that project:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">serverless create --template knative-docker --path my-knative-project\n\ncd my-knative-project</code></pre></div>\n<p>Because we’re using the <a href=\"https://github.com/serverless/serverless-knative\"><code class=\"language-text\">serverless-knative</code> provider plugin</a> we need to install all the dependencies of our template with <code class=\"language-text\">npm install</code> before we do anything else. This will download the provider plugin that was listed as a dependency in the <code class=\"language-text\">package.json</code> file.</p>\n<p>Next, let’s take a look at the <code class=\"language-text\">serverless.yml</code> file in our project which looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">service</span><span class=\"token punctuation\">:</span> my<span class=\"token punctuation\">-</span>knative<span class=\"token punctuation\">-</span>project\n\n<span class=\"token key atrule\">provider</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> knative\n  <span class=\"token comment\"># optional Docker Hub credentials you need if you're using local Dockerfiles as function handlers</span>\n  <span class=\"token key atrule\">docker</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">username</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>env<span class=\"token punctuation\">:</span>DOCKER_HUB_USERNAME<span class=\"token punctuation\">}</span>\n    <span class=\"token key atrule\">password</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>env<span class=\"token punctuation\">:</span>DOCKER_HUB_PASSWORD<span class=\"token punctuation\">}</span>\n\n<span class=\"token key atrule\">functions</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">hello</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">handler</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>world.dockerfile\n    <span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> ./code\n    <span class=\"token comment\"># events:</span>\n    <span class=\"token comment\">#   - custom:</span>\n    <span class=\"token comment\">#       filter:</span>\n    <span class=\"token comment\">#         attributes:</span>\n    <span class=\"token comment\">#           type: greeting</span>\n    <span class=\"token comment\">#   - kafka:</span>\n    <span class=\"token comment\">#       consumerGroup: KAFKA_CONSUMER_GROUP_NAME</span>\n    <span class=\"token comment\">#       bootstrapServers:</span>\n    <span class=\"token comment\">#         - server1</span>\n    <span class=\"token comment\">#         - server2</span>\n    <span class=\"token comment\">#       topics:</span>\n    <span class=\"token comment\">#         - my-topic</span>\n    <span class=\"token comment\">#   - awsSqs:</span>\n    <span class=\"token comment\">#       secretName: aws-credentials</span>\n    <span class=\"token comment\">#       secretKey: credentials</span>\n    <span class=\"token comment\">#       queue: QUEUE_URL</span>\n    <span class=\"token comment\">#   - gcpPubSub:</span>\n    <span class=\"token comment\">#       project: knative-hackathon</span>\n    <span class=\"token comment\">#       topic: foo</span>\n    <span class=\"token comment\">#   - cron:</span>\n    <span class=\"token comment\">#       schedule: '* * * * *'</span>\n    <span class=\"token comment\">#       data: '{\"message\": \"Hello world from a Cron event source!\"}'</span>\n\n<span class=\"token key atrule\">plugins</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> serverless<span class=\"token punctuation\">-</span>knative</code></pre></div>\n<p>This is the Serverless Framework service definition which lists Knative Serving components as <code class=\"language-text\">functions</code> with their potential event sources as <code class=\"language-text\">events</code>.</p>\n<p>You might be asking, this looks <em>too</em> simple. How is the Serverless Framework connecting with my cluster? Well, by default, we’re using the <code class=\"language-text\">~/.kube/config</code> that was created on your machine when you setup your cluster. To get other developers started you’ll also need to make sure they have access to your Kubernetes cluster and have their own <a href=\"https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/\">kubeconfig</a> file.</p>\n<p>Also, one critical part of the above is the Docker Hub section. At the moment, that section allows you to specify credentials so that your local Docker image and code in the <code class=\"language-text\">code</code> directory can be sent into Docker Hub and used by Knative. In order to enable it to work you’ll need to have a <a href=\"https://hub.docker.com/\">Docker Hub</a> account and set the docker environment variables locally. On Mac you can set those environment variables like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">DOCKER_HUB_USERNAME</span><span class=\"token operator\">=</span>yourusername\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">DOCKER_HUB_PASSWORD</span><span class=\"token operator\">=</span>yourpassword</code></pre></div>\n<p>Once the Docker Hub credentials are set as environment variables we can deploy a service to our Kubernetes cluster:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">serverless deploy</code></pre></div>\n<p>After the process finishes, invoking our new service is as easy as:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">serverless invoke --function hello</code></pre></div>\n<p>And congratulations! After you see a response, you’ve just deployed your first Serverless Framework service using Knative, Kubernetes and Google Cloud! </p>\n<p>Now, if you need to remove the Knative Service you can use:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">serverless remove</code></pre></div>\n<p>This should remove the Knative service but keep in mind that your Kubernetes cluster is still running! If you’d like to remove the cluster to save yourself some money you can run this command:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">gcloud container clusters delete $CLUSTER_NAME --zone $CLUSTER_ZONE</code></pre></div>\n<p>That should delete your cluster, but to be safe make sure to also confirm that it worked by checking inside of the GCP UI for your cluster.</p>\n<p>Now there’s a lot more you can do as you continue to work with Knative. You’ll probably want to try customizing your Docker containers with more interesting services, and integrate your Knative cluster with events from sources like Google Cloud Pub/Sub, Kafka, or AWS Simple Queue Service. There’s a lot of possibilities and we can’t wait to see what you do with it! </p>\n<p>Are you interested in guides on particular event sources or topics related to Knative and Serverless Framework? Leave us a comment below!</p>","frontmatter":{"title":"Deploying Your First Knative Service with the Serverless Framework","date":"January 24, 2020","description":"Learn how to use the Serverless Framework to deploy your first Knative service on a Kubernetes cluster running in Google Cloud."}}},"pageContext":{"slug":"/posts/2020-01-24-deploy-your-first-knative-service-with-the-serverless-framework/","previous":{"fields":{"slug":"/posts/2020-01-24-serverless-framework-knative-integration/"},"frontmatter":{"title":"The Serverless Framework Knative Integration"}},"next":{"fields":{"slug":"/posts/2020-02-03-announcement-cicd/"},"frontmatter":{"title":"Announcing Serverless CI/CD"}}}}}