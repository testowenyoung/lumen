{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2019-09-16-lambda-at-edge-support-added/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"577450b5-16e2-5ef1-a9d0-62e63299929d","excerpt":"Functions-as-a-Service (FaaS) offerings such as AWS Lambda are key components in modern Serverless application stacks as they receive and process the event data…","html":"<p>Functions-as-a-Service (FaaS) offerings such as AWS Lambda are key components in modern Serverless application stacks as they receive and process the event data generated by other cloud services such as storage buckets or databases.</p>\n<p>AWS announced AWS Lambda, their FaaS service, back in late 2014 alongside an S3 integration which made it possible to react on changes happening in S3 buckets. The primary use cases for AWS Lambda back then was to streamline the data processing pipelines many companies operate to crunch through the data stored in such buckets.</p>\n<p>The announcement of AWS API Gateway support for AWS Lambda finally made it possible to build 100% serverless web applications, removing the need to run and maintain a dedicated web server which processes incoming requests and serves responses. Since then web applications are the top use-case for serverless applications.</p>\n<p>Due to the growing interest in serverless web applications AWS introduced another type of Lambda function which is called <a href=\"https://aws.amazon.com/lambda/edge/\">Lambda@Edge</a>. With Serverless Framework v1.52.0 we’re adding native support for Lambda@Edge functions.</p>\n<p>In this post we’ll take a deeper dive into serverless web applications to see how they can benefit from Lambda@Edge functions. Before we get ahead of ourselves and talk about Lambda@Edge let’s recap what a typical serverless web application consists of.</p>\n<h4>Building serverless web applications</h4>\n<p>Roughly speaking web applications can be broken down into 2 parts: The frontend and the backend. Although serverless web applications are composed of several different cloud services one can still separate them into those 2 parts.</p>\n<p>Let’s take a look at the different pieces a modern, serverless web application is made of.</p>\n<h5>The frontend</h5>\n<p>The frontends main purpose is to serve the <code class=\"language-text\">.html</code>, <code class=\"language-text\">.css</code> and <code class=\"language-text\">.js</code> files alongside other static assets such as images which will be rendered by the consumer (usually the web browser) to display a UI our users can interact with.</p>\n<p>While our browser renders the static content it will also use our front ends JavaScript code to interact with our serverless backend (more on that in a minute).</p>\n<p>When using AWS to serve our frontend to our users we could use <a href=\"https://aws.amazon.com/s3/\">AWS S3</a> which is a storage solution to host our static assets and <a href=\"https://aws.amazon.com/cloudfront/\">AWS CloudFront</a>, a CDN service, to automatically distribute such assets in data centers all over the world.</p>\n<p>One might be asking, why CloudFront is necessary in this setup. Isn’t it enough to upload all the files to the S3 bucket and call it a day?</p>\n<p>Usually when a user would access our website, his request would be routed to our S3 bucket which in turn serves our public assets (such as <code class=\"language-text\">.html</code>, <code class=\"language-text\">.css</code> and <code class=\"language-text\">.js</code> files). While this initial setup works just fine, it’s often a better idea to cache content which is infrequently changed. That’s where AWS CloudFront comes in. With CloudFront we can set up a caching layer in front of our S3 bucket. This cache is distributed around the globe. User’s won’t download our assets from S3 but rather pull them from a CloudFront location nearby, which is way faster compared to an S3-only solution.</p>\n<h5>The backend</h5>\n<p>Having the frontend up and running, it’s time to take a quick look at a potential serverless web application backend. Depending on the use cases we usually need an API Gateway, data processing capabilities and a data storage solution.</p>\n<p>To satisfy such requirements, serverless web applications are usually built with <a href=\"https://aws.amazon.com/api-gateway/\">AWS API Gateway</a> which serves as the API Gateway, <a href=\"https://aws.amazon.com/lambda/\">AWS Lambda</a> to process the incoming event data and <a href=\"https://aws.amazon.com/dynamodb/\">AWS DynamoDB</a> which is used as the persistence layer (other DB solutions are available as well).</p>\n<p>When the user interacts with our web application frontend and wants to update his password, for example, a request will be sent from the frontend to API Gateway which is the entrypoint of our backend. API Gateway translates this request into an event which triggers our Lambda function. Such Lambda function will then process the event data and store the updated password in the DynamoDB table. Once done, a response is generated and sent back to the user via the API Gateway.</p>\n<p>As previously stated this setup is a very typical one for serverless web applications.</p>\n<p>Looking at the full stack consisting of frontend and backend one might ask if it’s truly necessary to perform a full roundtrip from the frontend to the backend and back again for every single user request.</p>\n<p>Imagine you’re operating a social networking site and you want to redirect mobile users to a dedicated “lite” version of your site which serves fewer content and hence loads faster. Wouldn’t it be a waste of time and resources to let the request travel all the way to your backend which detects that your user is using a mobile device and issues a redirect to your optimized mobile web app. Wouldn’t it be better to process that request “at the edge” without hitting the backend at all?</p>\n<p>That’s where Lambda@Edge comes in!</p>\n<h4>Lambda@Edge</h4>\n<p>Lambda@Edge is a compute offering by AWS which makes it possible to deploy AWS Lambda functions to edge locations which are served by CloudFront. Lambda@Edge functions are triggered by CloudFront events such as incoming requests or outgoing responses and can use this event information to rewrite such requests and responses (in our case inspecting the device type to issue a redirect when it’s a mobile device).</p>\n<p>Lambda@Edge functions are quite similar to regular AWS Lambda functions. In fact they are normal AWS Lambda functions which need to adhere to a few limitations:\nOnly versioned Lambda functions can be turned into Lambda@Edge functions\nLambda@Edge functions can have a maximum memory size of 128 MB\nLambda@Edge functions can have a maximum timeout of 5 seconds\nThe Lambda@Edge handler response is different compared to normal Lambda functions</p>\n<p>That being said there’s nothing new which needs to be learned in order to leverage Lambda@Edge functions. In fact the Serverless Framework v1.52.0 takes care of the heavy lifting for you. The only thing you need to do is to provide the function code and setup the corresponding <code class=\"language-text\">cloudFront</code> event in your <code class=\"language-text\">serverless.yml</code> file.</p>\n<p>Curious how this looks like? Let’s take a look at an example.</p>\n<h2>Example</h2>\n<p>Let’s implement our example of redirecting mobile users to a “light” web app URL without doing a full round trip from the frontend to the backend and back again.</p>\n<p>Let’s start with our <code class=\"language-text\">serverless.yml</code> file and turn our regular Lambda function into a Lambda@Edge function. Doing this is as easy as adding the <code class=\"language-text\">cloudFront</code> event to the <code class=\"language-text\">events</code> definition and setting the correct configuration parameters:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">service</span><span class=\"token punctuation\">:</span> cloudfront<span class=\"token punctuation\">-</span>service\n\n<span class=\"token key atrule\">provider</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> aws\n  <span class=\"token key atrule\">runtime</span><span class=\"token punctuation\">:</span> nodejs10.x\n\n<span class=\"token key atrule\">functions</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">cfLambda</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">handler</span><span class=\"token punctuation\">:</span> functions/handler.cloudfront\n    <span class=\"token key atrule\">events</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">cloudFront</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">eventType</span><span class=\"token punctuation\">:</span> origin<span class=\"token punctuation\">-</span>request\n          <span class=\"token key atrule\">origin</span><span class=\"token punctuation\">:</span> https<span class=\"token punctuation\">:</span>//app.acme.com</code></pre></div>\n<p>Here you can see that we’ve added the <code class=\"language-text\">cloudFront</code> event with an <code class=\"language-text\">eventType</code> configuration of <code class=\"language-text\">origin-request</code> and an<code class=\"language-text\">origin</code> configuration of <code class=\"language-text\">https://app.acme.com</code>. This configuration tells the Serverless Framework that we want to invoke our <code class=\"language-text\">cfLambda</code> function every time a request is sent to the <code class=\"language-text\">https://app.acme.com</code> origin.</p>\n<p>Next up we need to write the function logic to redirect mobile users to our “lite” version of our web application.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n\nexports<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">handler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> callback</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> request <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>Records<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>cf<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> headers <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>headers<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>headers<span class=\"token punctuation\">[</span><span class=\"token string\">'cloudfront-is-mobile-viewer'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> headers<span class=\"token punctuation\">[</span><span class=\"token string\">'cloudfront-is-mobile-viewer'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">===</span> <span class=\"token string\">'true'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        request<span class=\"token punctuation\">.</span>uri <span class=\"token operator\">=</span> '<span class=\"token operator\">/</span>lite <span class=\"token operator\">+</span> request<span class=\"token punctuation\">.</span>uri<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This functionality is triggered every time a request is routed through our CloudFront distribution. Once this happens we take a look into the request headers to see if it’s a mobile user. If that’s the case we prepend the <code class=\"language-text\">/lite</code> string to our uri and return the request.</p>\n<p>That’s it. We’re now ready to deploy our Lambda@Edge function. As per usual, deploying this service is a simple as running <code class=\"language-text\">serverless deploy</code>.</p>\n<p>Note that the deployment might take a while since AWS will setup a CloudFront distribution for you behind the scenes and replicates your Lambda function across the globe.</p>\n<p>Once done you should see the CloudFront endpoint in your deployment summary. If you visit this endpoint with a mobile device you’ll be redirected to the “lite” version of your webapp!</p>\n<h5>A note about removals</h5>\n<p>When you’re done with testing you might want to remove the service via <code class=\"language-text\">serverless remove</code>. Note that the removal also takes a little bit longer and won’t remove your Lambda@Edge functions automatically. The reason is that AWS has to cleanup your functions replicas which can take a couple of hours. Removing the Lambda functions too early would result in an error.</p>\n<p>The solution for this problem right now is to manually remove the Lambda@Edge functions via the AWS console after a couple of hours. You might want to automate this process with a script which issues AWS SDK calls to streamline this cleanup process.</p>\n<h4>Conclusion</h4>\n<p>AWS Lambda@Edge is a great way to run function code in edge locations which are near to the user and therefore typically offer lower latency.</p>\n<p>Lambda@Edge functions are regular, “trimmed down” Lambda functions which can read and modify the request and response data. This makes it possible to e.g. intercept incoming requests and return a response immediately without passing the data through to the backend services. Typical <a href=\"https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-examples.html\">Lambda@Edge uses cases</a> include rewriting of response URLs based on device types or IP addresses, identifying crawlers and serving static, pre rendered assets, on-the-fly content compression or authentication header manipulations.</p>\n<p>With Serverless Framework v1.52.0 we’re adding native support for Lambda@Edge functions via the <code class=\"language-text\">cloudFront</code> event. Every Lambda function can easily be turned into a Lambda@Edge function and deployed via the familiar <code class=\"language-text\">serverless deploy</code> command. You can read more about the <code class=\"language-text\">cloudFront</code> event type in our <a href=\"https://serverless.com/framework/docs/providers/aws/events/cloudfront/\"><code class=\"language-text\">cloudFront</code> event documentation</a>.</p>\n<p>We hope that you enjoy this new functionality. What do you think about Lambda@Edge? How are you planning to use it? Let us know via <a href=\"https://twitter.com/goserverless\">@goserverless on Twitter</a> or leave a comment below!</p>","frontmatter":{"title":"Lambda@Edge support now available","date":"September 16, 2019","description":"Using Lambda@Edge is a great way to speed up your application. And the Serverless Framework now has support for it."}}},"pageContext":{"slug":"/posts/2019-09-16-lambda-at-edge-support-added/","previous":{"fields":{"slug":"/posts/2019-09-12-monitor-and-debug-all-serverless-errors/"},"frontmatter":{"title":"Monitor and debug all serverless errors"}},"next":{"fields":{"slug":"/posts/2019-09-17-serverless-nextjs/"},"frontmatter":{"title":"Serverless Next.js At The Edge"}}}}}