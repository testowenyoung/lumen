{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2019-07-08-dynamic-image-resizing-ruby/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"a97b1293-b084-5993-893b-8e18c997c3b4","excerpt":"If you’ve grappled with resizing images for various page layouts and devices, you know the pain of accounting for all different types of screens, the scaling…","html":"<p>If you’ve grappled with resizing images for various page layouts and devices, you know the pain of accounting for all different types of screens, the scaling problem that serving the full-size original image presents, and the fact that large images increase page load times and increase bounce rates. And the difference between an original image and a compressed one is essentially unnoticeable to the user.</p>\n<p>And so it follows that you’ll want to generate and serve an image of lower but still good quality. However, it’s not possible to know in advance which image sizes to serve. And pre-scaling the original image to all imaginable sizes will result in an unsustainable hit to your cloud storage capacity and therefore to your monthly bill.</p>\n<p>What if there were a way to easily build applications using functionality available from cloud providers, for example AWS Lambda, that could scale your images on the fly? <a href=\"https://serverless.com/framework/\">The Serverless framework</a> provides such a solution with its auto-scaling, pay-per-execution functions, which circumvents keeping a massive collection of pre-scaled cloud data. As an added bonus, maintaining multiple, often-idle servers is unnecessary when using the Serverless framework, so your app will save significantly on compute costs.</p>\n<p>In this article, we’ll take an in-depth look at the benefits of dynamic image resizing and walk you through using the Serverless framework to resize your images dynamically with AWS Lambda.</p>\n<h2>A solution using S3</h2>\n<p>In this example, we’ll be using Ruby in conjunction with the Serverless framework to build our app. We’ll also use the AWS cloud storage service, S3, but the Serverless framework also supports Azure, GCP and Kubernetes, among other cloud providers.</p>\n<p>First, we’ll pick a few ranges of possible image sizes (for example, we’d serve one size image to screens 320-720px wide, and a slightly larger image to those 720-1024px wide). Then, we’ll build a system from event-driven functions that will generate the specified image sizes from the original photo.</p>\n<p>When a device requests our site, if we don’t have the correctly sized image yet, following the S3 link will first generate the image in that size and then serve it to us. This newly resized image is then stored in S3 for future use. If the correctly sized image in our S3 storage does already exist, calling the corresponding S3 URI will directly serve us the previously stored image.</p>\n<p>We make the system smart by only generating image sizes requested by specific devices. If a particular article has only been viewed by 640px-wide screens, the Serverless app won’t generate the rest of the sizes until someone with a different screen size comes along. The first reader with a 800px screen to load the article must wait for a split second while the system generates the new image size, but the user experience impact is minimal. Once the new size has been generated, we save it for future use.</p>\n<p>Since you are not maintaining idle servers, if no users visit your site, no code will run and you won’t pay for anything. When new visitors do begin needing different image sizes, the system will scale, doing all the necessary work. But this approach is efficient: the system stops running as soon there are no more new images to generate. The Serverless framework also provides an optimal experience for users, as their devices get served the right size image in a timely manner. This approach thus offers an easy, low-cost and scalable solution.</p>\n<h2>Creating a Serverless API for image resizing</h2>\n<p>How exactly do we go about implementing the Serverless image-resizing API? In this section, we’ll cover the following steps:</p>\n<ul>\n<li>Writing a serverless.yml config file that contains all the specifics for the resizing service</li>\n<li>Generating and redirecting to a new image URL in a handler function</li>\n<li>Implementing the resizing logic in a resizing function</li>\n<li>Setting up an S3 bucket to work with the resizing endpoint</li>\n</ul>\n<h3>Writing the serverless.yml file</h3>\n<p>Our <a href=\"https://github.com/chief-wizard/serverless-ruby-image-resizing/blob/master/serverless.yml\">serverless.yml</a> file defines the Ruby environment for our resizing function defined above. We first specify our cloud provider (AWS) and a Ruby version that works for us. We also give it the right IAM roles so that it can interact with S3.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">provider</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> aws\n  <span class=\"token key atrule\">runtime</span><span class=\"token punctuation\">:</span> ruby2.5\n  <span class=\"token key atrule\">region</span><span class=\"token punctuation\">:</span> eu<span class=\"token punctuation\">-</span>west<span class=\"token punctuation\">-</span><span class=\"token number\">1</span>\n  <span class=\"token key atrule\">iamRoleStatements</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">Effect</span><span class=\"token punctuation\">:</span> Allow\n      <span class=\"token key atrule\">Action</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> s3<span class=\"token punctuation\">:</span>*\n      <span class=\"token key atrule\">Resource</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'*'</span></code></pre></div>\n<p>Next, we define the function that we’ll expose (<code class=\"language-text\">resize</code>), along with the <code class=\"language-text\">BUCKET</code> and <code class=\"language-text\">REGION</code> environment variables. Let’s also add an event to our function, which in this case is an HTTP path that our function will work with. As you might imagine, <code class=\"language-text\">{size}</code> will become the <code class=\"language-text\">size</code> parameter <a href=\"https://github.com/chief-wizard/serverless-ruby-image-resizing/blob/master/handler.rb#L6\">here</a>, and <code class=\"language-text\">{image}</code> will become the <code class=\"language-text\">image</code> parameter <a href=\"https://github.com/chief-wizard/serverless-ruby-image-resizing/blob/master/handler.rb#L7\">here</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">functions</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">resize</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">handler</span><span class=\"token punctuation\">:</span> handler.call\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">BUCKET</span><span class=\"token punctuation\">:</span> resized<span class=\"token punctuation\">-</span>images<span class=\"token punctuation\">-</span>ruby\n      <span class=\"token key atrule\">REGION</span><span class=\"token punctuation\">:</span> eu<span class=\"token punctuation\">-</span>west<span class=\"token punctuation\">-</span><span class=\"token number\">1</span>\n    <span class=\"token key atrule\">events</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">http</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">path</span><span class=\"token punctuation\">:</span> /<span class=\"token punctuation\">{</span>size<span class=\"token punctuation\">}</span>/<span class=\"token punctuation\">{</span>image<span class=\"token punctuation\">}</span>\n          <span class=\"token key atrule\">method</span><span class=\"token punctuation\">:</span> get</code></pre></div>\n<h3>The handler function</h3>\n<p>Our image-resizing handler function itself will live in <a href=\"https://github.com/chief-wizard/serverless-ruby-image-resizing/blob/master/handler.rb\">handler.rb</a>. First, it will accept an HTTP request. After receiving this path, let’s extract the size and image from it:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">size <span class=\"token operator\">=</span> event\\<span class=\"token punctuation\">[</span><span class=\"token string\">\"pathParameters\"</span>\\<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"size\"</span><span class=\"token punctuation\">]</span>\nimage <span class=\"token operator\">=</span> event\\<span class=\"token punctuation\">[</span><span class=\"token string\">\"pathParameters\"</span>\\<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"image\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>By calling <code class=\"language-text\">resizeImage.new</code> on the size and image, we convert the parameters to integers and construct the new image URL where we can find the resized image after conversion:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">resized_image_url <span class=\"token operator\">=</span> <span class=\"token constant\">ResizeImage</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>call</code></pre></div>\n<p>The handler then returns an HTTP 301 redirect to the location of the new image once it’s been successfully generated.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n      headers: { location: resized_image_url },\n      statusCode: 301,\n      body: &#39;&#39;\n}</code></pre></div>\n<p>Aside from these elements, the only other code in <code class=\"language-text\">handler.rb</code> is our standard error handler. As you can see, in this file we simply call <code class=\"language-text\">ResizeImage.new(image, size)</code>, but to keep things tidy, let’s put the resizing logic somewhere else. We’ll now switch to <code class=\"language-text\">resize_image.rb</code> to look at that underlying logic.</p>\n<h3>Image Resizing</h3>\n<p>The resizing functionality will live in the <a href=\"https://github.com/chief-wizard/serverless-ruby-image-resizing/blob/master/resize_image.rb\">resize_image.rb</a> file. First, we need to download the file that needs to be resized.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">download_object</span></span>\n  source<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>response_target<span class=\"token punctuation\">:</span> tmp_file_name<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>We then define the function which actually does the resizing work.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">resize</span></span>\n  image <span class=\"token operator\">=</span> <span class=\"token constant\">MiniMagick</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">Image</span><span class=\"token punctuation\">.</span>open<span class=\"token punctuation\">(</span>tmp_file_name<span class=\"token punctuation\">)</span>\n  image<span class=\"token punctuation\">.</span>resize<span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span>\n  image<span class=\"token punctuation\">.</span>write<span class=\"token punctuation\">(</span><span class=\"token constant\">RESIZED_FILE_TMP</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>After that, we upload the resized object to S3.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">upload_object</span></span>\n  bucket<span class=\"token punctuation\">.</span>object<span class=\"token punctuation\">(</span>resized_object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>upload_file<span class=\"token punctuation\">(</span><span class=\"token constant\">RESIZED_FILE_TMP</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>Lastly, we wire the preceding three functions together.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">call</span></span>\n  download_object\n  resize\n  upload_object\n\n  <span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span><span class=\"token constant\">BUCKET_URL</span><span class=\"token delimiter tag\">}</span></span>/<span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span>resized_object<span class=\"token delimiter tag\">}</span></span>\"</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>We need the rest of the definitions in <code class=\"language-text\">resize_image.rb</code> (after “private”) to make sure we have a clean way to do all the resizing work. These definitions hold temporary variables needed to name, resize, and upload the new image, but are not relevant in the final product, so keeping these private ensures the code stays clean.</p>\n<h2>Deploying the image resizing API</h2>\n<p>Our API is all set up, and we’re ready for deployment. One last step before running the deploy command is to set up the AWS credentials in the <code class=\"language-text\">.env</code> file in the root of the project. Take a look at the example <code class=\"language-text\">.env</code> file in the GitHub repo <a href=\"https://github.com/chief-wizard/serverless-ruby-image-resizing/blob/master/.env.example\">here</a>. Please make sure that you don’t check the <code class=\"language-text\">.env</code> file into Git, as that might leak your AWS credentials. We have added this file to the list of ignored files in <a href=\"https://github.com/chief-wizard/serverless-ruby-image-resizing/blob/master/.gitignore#L8\">.gitignore</a> to prevent you from accidentally publishing your AWS credentials.</p>\n<p>Once the AWS credentials are set up, we can deploy the change(s) to our <code class=\"language-text\">serverless.yml</code> file by running</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">serverless deploy</code></pre></div>\n<p>This translates the syntax of our <code class=\"language-text\">serverless.yml</code> file into an AWS CloudFormation template and sends that change to AWS. For more on the deployment process, take a look at the <a href=\"https://serverless.com/framework/docs/providers/aws/guide/deploying/\">Serverless AWS documentation</a>.</p>\n<h3>Setting up the S3 bucket</h3>\n<p>As mentioned above, our Serverless function works with AWS S3, so we need to set up our S3 bucket that will store our already requested image sizes. The core functionality we want is as follows:</p>\n<ol>\n<li>If the image exists in the right size in the S3 bucket, return it to the requester.</li>\n<li>If the image does not yet exist in the requested size, download the original size, resize the image, return the resized image to the requester and save it in our S3 bucket.</li>\n</ol>\n<p>To get this working, we will need to make the following changes in our S3 bucket configuration:</p>\n<ol>\n<li>Ensure our S3 bucket is configured for website hosting as <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/dev/HowDoIWebsiteConfiguration.html\">explained in the S3 documentation</a>.</li>\n<li>In the <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html#advanced-conditional-redirects\">Advanced Conditional Redirects</a> stanza of the Website Hosting settings for the S3 bucket, set up the following redirect rule:</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>RoutingRules</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>RoutingRule</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Condition</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>HttpErrorCodeReturnedEquals</span><span class=\"token punctuation\">></span></span>404<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>HttpErrorCodeReturnedEquals</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Condition</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Redirect</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Protocol</span><span class=\"token punctuation\">></span></span>https<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Protocol</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>HostName</span><span class=\"token punctuation\">></span></span>YOUR-API-ENDPOINT.execute-api.eu-west-1.amazonaws.com<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>HostName</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ReplaceKeyPrefixWith</span><span class=\"token punctuation\">></span></span>dev-1/<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ReplaceKeyPrefixWith</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>HttpRedirectCode</span><span class=\"token punctuation\">></span></span>307<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>HttpRedirectCode</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Redirect</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>RoutingRule</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>RoutingRules</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>In place of <code class=\"language-text\">YOUR-API-ENDPOINT</code>, we will add the Lambda endpoint of our Serverless function. We can get that by running:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">serverless info</code></pre></div>\n<p>Keep in mind that if you specify a custom stage during deployment, you also need to specify it in the <code class=\"language-text\">info</code> command, the output of which is information about the deployed service. We are specifically looking for the right endpoint address in this output. See the docs for the <a href=\"https://serverless.com/framework/docs/providers/aws/cli-reference/info/\">info command for more details</a>.</p>\n<h3>The API in action</h3>\n<p>We’ve set up our code, so let’s now take a look at our work in action. We’ll first request a size we know exists:</p>\n<img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/image-processing-post/2019-07-08-image-ruby.gif\">\n<p>Now we’ll request the image in a size that doesn’t exist yet:</p>\n<img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/image-processing-post/2019-07-08-image-ruby2.gif\">\n<p>It works! The next time we request this size, the image will be served directly from S3.</p>\n<h2>Wrapping up</h2>\n<p>In this article, we saw that image resizing using Serverless keeps costs low, provides users with a good experience and scales images perfectly with our needs. We did this by walking through the process of creating a Serverless app that resizes images dynamically.</p>\n<p>New users to Serverless will find that building an app for resizing images is a great introduction to the framework. But Serverless is also applicable to much more complex cases, such as event streaming and processing, building multilingual apps and workflow automation.</p>\n<p>The Serverless Framework <a href=\"https://serverless.com/framework/docs/getting-started/\">documentation</a> is a great place to begin. You can also read the <a href=\"https://serverless.com/framework/docs/providers/aws/guide/intro/\">AWS-based introduction to the Serverless framework</a>. If you’ll be using another cloud provider, <a href=\"https://serverless.com/framework/docs/#Supported-Providers\">Serverless can help you there too</a>.</p>\n<p><a href=\"https://github.com/chief-wizard/serverless-ruby-image-resizing\">This Github repo</a> contains the full example project.</p>","frontmatter":{"title":"Dynamic image resizing with Ruby and Serverless framework","date":"July 08, 2019","description":"In this article we will provide an example of how to dynamically resize images with Ruby and the Serverless framework."}}},"pageContext":{"slug":"/posts/2019-07-08-dynamic-image-resizing-ruby/","previous":{"fields":{"slug":"/posts/2019-07-02-graphql-api-mysql-postgres-aurora/"},"frontmatter":{"title":"How to Create a Serverless GraphQL API for MySQL, Postgres and Aurora"}},"next":{"fields":{"slug":"/posts/2019-07-09-buildcenter-serverless-development-cycle/"},"frontmatter":{"title":"How BuildCenter and Serverless Guru Streamlined Their Serverless Development Cycle"}}}}}