{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2019-11-05-structuring-a-real-world-serverless-app/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"8c5610ea-fdcc-54b5-bbe2-a0f45817a9a4","excerpt":"As your Serverless app starts to grow, you reach a point where you are trying to figure out how best to organize it. In this post we’ll share some of the best…","html":"<p>As your Serverless app starts to grow, you reach a point where you are trying to figure out how best to organize it. In this post we’ll share some of the best practices for organizing and managing large Serverless applications.</p>\n<p>Here are a few things we’ll be covering:</p>\n<ul>\n<li>Organizing your services in repos</li>\n<li>\n<p>Organizing Lambda functions</p>\n<ul>\n<li>Sharing dependencies</li>\n<li>Sharing code between services</li>\n<li>Sharing <code class=\"language-text\">serverless.yml</code> config</li>\n<li>Sharing an API Gateway endpoint</li>\n</ul>\n</li>\n<li>Deploying an entire app</li>\n</ul>\n<p>A quick reminder on the definitions before we get started. An app is a collection of services. Where a service is configured using a single <code class=\"language-text\">serverless.yml</code> file.</p>\n<h1>Organizing services</h1>\n<p>There are some very passionate arguments on the advantages and disadvantages of a monorepo vs multi-repo setup. We are not going to be focusing on their specific details here. But we want to pick a setup that allows us to:</p>\n<ul>\n<li>Share code and config easily between services</li>\n<li>Make it easy to create and configure new environments from the repos</li>\n<li>And make our deployment process as simple as possible</li>\n</ul>\n<p>For starters, Serverless effectively requires you to adopt the infrastructure as code paradigm. This usually makes it so that your AWS resources and business logic code end up being closely coupled. But often you can draw a line between the resources that get updated frequently and the ones that aren’t. For example, your Lambda functions and API Gateway endpoints get updated fairly frequently. While, resources like DynamoDB, Cognito, or S3 are less likely to do so.</p>\n<p>Additionally, your Lambda functions have all your business logic code. They need to be able to share code and config easily between themselves.</p>\n<p>So if you are creating a Serverless API backend, you’ll have roughly two types of resources: your infrastructure resources and the Lambda functions for your API endpoints. It often ends up easier to keep them in separate repos.</p>\n<p>Why? Most of the code changes are going to happen in the repo with the Lambda functions. When your team is making rapid changes, you are likely to have many feature branches, bug fixes, and pull requests. A bonus with Serverless is that you can spin up new environments at zero cost (you only pay for usage, not for provisioning resources). So, a team can have dozens of ephemeral stages such as: prod, staging, dev, feature-x, feature-y, feature-z, bugfix-x, bugfix-y, pr-128, pr-132, etc. This ensures each change is tested on real infrastructure before being promoted to production.</p>\n<p>On the other hand, changes are going to happen less frequently to the infrastructure repo. And most likely you don’t need a complete set of standalone DynamoDB tables for each feature branch. In fact, a team will usually have a couple of long-lived environments: dev and prod (and optionally staging). While the feature/bugfix/PR environments of the Lambda functions will connect to the dev environment of the resources.</p>\n<p>Here’s a little diagram to illustrate the above setup.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/serverless+app+setup/unnamed.png\" alt=\"Real-world Serverless app repo structure\"></p>\n<h1>Organizing your Lambda functions</h1>\n<p>Now that we have our repos organized, let’s take a look at how we structure the code for our Lambda functions.</p>\n<h2>Sharing dependencies</h2>\n<p>Let’s start by looking at how you’ll set up your dependencies. We’ll be looking at a Node.js example here. Continuing from the above example, let’s have a look at how the repo for your Lambda functions:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/\n  package.json\n  config.js\n  serverless.common.yml\n  libs/\n  services/\n    notes-api/\n      package.json\n      serverless.yml\n      handler.js\n    billing-api/\n      package.json\n      serverless.yml\n      handler.js\n    notify-job/\n      serverless.yml\n      handler.js</code></pre></div>\n<p>The first question you’ll typically have is about the <code class=\"language-text\">package.jon</code> is — “Do I just have one <code class=\"language-text\">package.json</code> or do I have one for each service?“. We recommend having multiple <code class=\"language-text\">package.json</code> files. You could use something like <a href=\"https://lerna.js.org\">Lerna</a> or <a href=\"https://yarnpkg.com/lang/en/docs/workspaces/\">Yarn Workspaces</a> here but we are keeping things simple. We want you to be able to use this setup as a starting point for your projects and leave that option up to you.</p>\n<p>We use the <code class=\"language-text\">package.json</code> at the project root to install the dependencies that will be shared across all the services. For example, if you are using <a href=\"https://github.com/AnomalyInnovations/serverless-bundle\">serverless-bundle</a> to optimally package the Lambda functions, or using the <a href=\"https://github.com/FidelLimited/serverless-plugin-warmup\">serverless-plugin-warmup</a> to reduce cold starts, they should be installed at the root level. It doesn’t make sense to install them in each and every single service.</p>\n<p>On the other hand, dependencies that are specific to a single service are installed in the <code class=\"language-text\">package.json</code> for that service. In our example, the <code class=\"language-text\">billing-api</code> service uses the <code class=\"language-text\">stripe</code> NPM package. So it’s added just to that <code class=\"language-text\">package.json</code>.</p>\n<p>This setup implies that when you are deploying your app through a CI; you’ll need to do an <code class=\"language-text\">npm install</code> twice. Once at the root and once in a specific service directory.</p>\n<h2>Sharing code between services</h2>\n<p>The biggest reason to use a monorepo setup is to be able to easily share common code between your services.</p>\n<p>Alternatively, you could use a multi-repo approach where all your common code is published as private NPM packages. This adds an extra layer of complexity. This only makes sense if you grow to the point where different teams are working on different services while sharing the same common code. In this scenario, making updates to the common code can potentially affect a very large number of services and Lambda functions. For this case it just makes a lot more sense to host your common code in versioned packages. This allows teams to explicitly decide when they want to update the common code.</p>\n<p>In our example, we’ll try to share some common code. We’ll be placing these in a <code class=\"language-text\">libs/</code> directory. Our services need to make calls to various AWS services using the AWS SDK. And we have the common SDK configuration code in the <code class=\"language-text\">libs/aws-sdk.js</code> file. For example, we might want to optionally enable tracing through AWS X-Ray across all of our services.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> aws <span class=\"token keyword\">from</span> <span class=\"token string\">\"aws-sdk\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> xray <span class=\"token keyword\">from</span> <span class=\"token string\">\"aws-xray-sdk\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Do not enable tracing for 'invoke local'</span>\n<span class=\"token keyword\">const</span> awsWrapped <span class=\"token operator\">=</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">IS_LOCAL</span> <span class=\"token operator\">?</span> aws <span class=\"token operator\">:</span> xray<span class=\"token punctuation\">.</span><span class=\"token function\">captureAWS</span><span class=\"token punctuation\">(</span>aws<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> awsWrapped<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Our Lambda functions will now import this, instead of the standard AWS SDK.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token constant\">AWS</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../../libs/aws-sdk'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The great thing about this is that we can easily change any AWS related config and it’ll apply across all of our services.</p>\n<h2>Sharing <code class=\"language-text\">serverless.yml</code> config</h2>\n<p>We have separate <code class=\"language-text\">serverless.yml</code> configs for our services. However, we might need to share some config across all of our <code class=\"language-text\">serverless.yml</code> files. To do that:</p>\n<ol>\n<li>Place the shared config values in a common yaml file at the root.</li>\n<li>And reference them in your individual <code class=\"language-text\">serverless.yml</code> files.</li>\n</ol>\n<p>For example, we want to be able to use X-Ray, we need to grant the necessary X-Ray permissions in the Lambda IAM role. So we added a <code class=\"language-text\">serverless.common.yml</code> at the repo root.</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">lambdaPolicyXRay</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">Effect</span><span class=\"token punctuation\">:</span> Allow\n  <span class=\"token key atrule\">Action</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> xray<span class=\"token punctuation\">:</span>PutTraceSegments\n    <span class=\"token punctuation\">-</span> xray<span class=\"token punctuation\">:</span>PutTelemetryRecords\n  <span class=\"token key atrule\">Resource</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"*\"</span></code></pre></div>\n<p>And in each of our services, we include the <strong>lambdaPolicyXRay</strong> IAM policy:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">iamRoleStatements</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> $<span class=\"token punctuation\">{</span>file(../../serverless.common.yml)<span class=\"token punctuation\">:</span>lambdaPolicyXRay<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Sharing an API Gateway endpoint</h2>\n<p>A challenge that you run into when splitting your APIs into multiple services is sharing the same domain for them. You might recall that APIs that are created as a part of a service get their own unique URL that looks something like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">https://z6pv80ao4l.execute-api.us-east-1.amazonaws.com/dev</code></pre></div>\n<p>When you attach a custom domain for your API, it’s attached to a specific endpoint like the one above. This means that if you create multiple API services, they will all have unique endpoints.</p>\n<p>You can assign different base paths for your custom domains. For example, <code class=\"language-text\">api.example.com/notes</code> can point to one service while <code class=\"language-text\">api.example.com/billing</code> can point to another. But if you try to split your <code class=\"language-text\">notes</code> service up, you’ll face the challenge of sharing a custom domain across them.</p>\n<p>In our example app, we have two services with API endpoints, <code class=\"language-text\">notes-api</code> and <code class=\"language-text\">billing-api</code>. Let’s look at how to configure API Gateway such that both services are served out via a single API endpoint.</p>\n<p>In the <code class=\"language-text\">notes-api</code>, we will export the API Gateway resources:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">...</span>\n\n<span class=\"token punctuation\">-</span> <span class=\"token key atrule\">Outputs</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">ApiGatewayRestApiId</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">Value</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">Ref</span><span class=\"token punctuation\">:</span> ApiGatewayRestApi\n      <span class=\"token key atrule\">Export</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">Name</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>custom.stage<span class=\"token punctuation\">}</span><span class=\"token punctuation\">-</span>ExtApiGatewayRestApiId\n  \n    <span class=\"token key atrule\">ApiGatewayRestApiRootResourceId</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">Value</span><span class=\"token punctuation\">:</span>\n         <span class=\"token key atrule\">Fn::GetAtt</span><span class=\"token punctuation\">:</span>\n          <span class=\"token punctuation\">-</span> ApiGatewayRestApi\n          <span class=\"token punctuation\">-</span> RootResourceId \n      <span class=\"token key atrule\">Export</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">Name</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>custom.stage<span class=\"token punctuation\">}</span><span class=\"token punctuation\">-</span>ExtApiGatewayRestApiRootResourceId</code></pre></div>\n<p>And in the <code class=\"language-text\">billing-api</code>, we will import the above:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">...</span>\n\n<span class=\"token key atrule\">provider</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">apiGateway</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">restApiId</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">'Fn::ImportValue'</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>custom.stage<span class=\"token punctuation\">}</span><span class=\"token punctuation\">-</span>ExtApiGatewayRestApiId\n    <span class=\"token key atrule\">restApiRootResourceId</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">'Fn::ImportValue'</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>custom.stage<span class=\"token punctuation\">}</span><span class=\"token punctuation\">-</span>ExtApiGatewayRestApiRootResourceId\n<span class=\"token punctuation\">...</span></code></pre></div>\n<p>This allows us to share the same endpoint across these two services. Next let’s look at how to deploy our app.</p>\n<h1>Deploying the entire app</h1>\n<p>Our services have a couple of interdependencies. This adds a bit of a wrinkle to our deployment process. Let’s look at this in detail.</p>\n<h3>First deployment</h3>\n<p>Note that by sharing an API Gateway project, we are making the <code class=\"language-text\">billing-api</code> depend on the <code class=\"language-text\">notes-api</code>. When deploying for the first time, you need to ensure the <code class=\"language-text\">notes-api</code> is deployed first.</p>\n<p>If both the services are deployed concurrently, the <code class=\"language-text\">billing-api</code> will fail simply because the ARN referenced in its <code class=\"language-text\">serverless.yml</code> does not exist. This makes sense because we haven’t created it yet!</p>\n<h3>Subsequent deployments</h3>\n<p>Once all the services have been successfully deployed, you can deploy them all concurrently. This is because the referenced ARN has already been created.</p>\n<h3>Adding new dependencies</h3>\n<p>Say you add a new SNS topic in the <code class=\"language-text\">notes-api</code> service and you want the <code class=\"language-text\">billing-api</code> service to subscribe to that topic. The first deployment after the change, will again fail if all the services are deployed concurrently. You need to deploy the <code class=\"language-text\">notes-api</code> service before deploying the <code class=\"language-text\">billing-api</code> service.</p>\n<h3>Deploying only updated services</h3>\n<p>Once your application grows and you have dozens of services, you’ll notice that repeatedly deploying all your services is not very fast. One way to speed it up is to only deploy the services that’ve been updated. You can do this by checking if there are any commits in a service’s directory.</p>\n<p>Upon deployment, you can run the following command to get a list of updates:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> <span class=\"token function\">diff</span> --name-only <span class=\"token variable\">${prevCommitSHA}</span> <span class=\"token variable\">${currentCommitSHA}</span></code></pre></div>\n<p>This will give you a list of files that have been updated between the two commits. With the list of changed files, there are three scenarios from the perspective of a given service. We are going to use <code class=\"language-text\">notes-api</code> as an example:</p>\n<ol>\n<li>A file was changed in my service’s directory (ie. <code class=\"language-text\">services/notes-api</code>) ⇒ we deploy the <code class=\"language-text\">notes-api</code> service.</li>\n<li>A file was changed in another service’s directory (ie. <code class=\"language-text\">services/billing-api</code>) ⇒ we do not deploy the <code class=\"language-text\">notes-api</code> service.</li>\n<li>Or, a file was changed in <code class=\"language-text\">libs/</code> ⇒ we deploy the <code class=\"language-text\">notes-api</code> service.</li>\n</ol>\n<p>Your repo setup can look different, but the general concept still holds true. You have to figure out if a file change affects an individual service, or if a file change affects all the services. The advantage of this strategy is that you know upfront which services can be skipped. This allows you to skip a portion of the entire build process, thus speeding up you’re builds. A shameless plug here, <a href=\"https://seed.run\">Seed</a> supports this and the setup outlined in this post out of the box!</p>\n<h1>Summary</h1>\n<p>Hopefully, this post gives you a good idea of how to structure your Serverless application. We’ve seen the above setup work really well for folks in production. It gives you enough structure to help you as your app and team grows. While still allowing you to retain the flexibility to make changes along the way.</p>\n<p>Give this setup a try and make sure to share your feedback in the comments below!</p>","frontmatter":{"title":"Structuring a Real-World Serverless App","date":"November 05, 2019","description":"In this post we'll be looking at how to structure a real-world Serverless Framework application."}}},"pageContext":{"slug":"/posts/2019-11-05-structuring-a-real-world-serverless-app/","previous":{"fields":{"slug":"/posts/2019-10-31-aws-lambda-vs-ec2-for-cron-jobs/"},"frontmatter":{"title":"Running cron jobs in the cloud - Amazon EC2 vs AWS Lambda"}},"next":{"fields":{"slug":"/posts/2019-11-06-tencent-partnership/"},"frontmatter":{"title":"Tencent Cloud and Serverless Join Forces to Bring the Serverless Movement to China"}}}}}