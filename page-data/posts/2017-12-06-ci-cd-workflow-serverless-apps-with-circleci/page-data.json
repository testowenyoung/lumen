{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2017-12-06-ci-cd-workflow-serverless-apps-with-circleci/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"2272e12f-45d1-5b77-8e76-40ec54f86e70","excerpt":"It’s pretty easy to set up a simple Serverless app with the Serverless Framework. But—in real life, the process of continuous integration and deployment (CI/CD…","html":"<p>It’s pretty easy to set up a <a href=\"https://serverless.com/blog/anatomy-of-a-serverless-app/\">simple Serverless app</a> with the <a href=\"https://serverless.com/framework/\">Serverless Framework</a>. <em>But</em>—in real life, the process of continuous integration and deployment (CI/CD) of that application can be much more involved.</p>\n<p>Never fear! In this post, we’re going to take a deep look at the end-to-end workflow of automating a CI/CD process for a serverless application via CircleCI.</p>\n<p>We will cover:</p>\n<ul>\n<li>Defining the CI/CD process</li>\n<li>Creating an app with testable code</li>\n<li>Preparing the app for automation</li>\n<li>Integrating with a CI/CD toolchain</li>\n<li>End-to-end automation for our app</li>\n<li>Advanced deployment patterns</li>\n</ul>\n<p>If you already know some CI/CD basics, then you’ll probably want to skip straight to the <a href=\"#application-testing\">application testing</a> bit.</p>\n<h4>The Basics: CI/CD Overview</h4>\n<p>In an agile development environment, small teams work autonomously and add a lot of churn to the code base. Each developer works on different aspects of the project and commits code frequently.</p>\n<p>This is a healthy practice, but it comes with some challenges. Without close watch and proper communication about changes, the updates can cause existing code to break. To minimize manual scrutiny and redundant communication across teams, we need to invest in automating CI/CD processes.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/cicd/cicd-process.gif\" alt=\"The CI/CD Process Flow\"></p>\n<p><em>Figure 1: The CI/CD Process Flow</em></p>\n<h5>Continuous Integration</h5>\n<p>The CI process starts with the developer checking code into a code repository. The developer makes their code changes in a local branch, then adds units tests and integration tests. They ensure that the tests don’t lower the overall code coverage. It’s possible to automate this process by having a common script that can run the unit tests, integration tests and code coverage.</p>\n<p>Once the code is tested in the context of the local branch, the developer needs to merge the master branch into their local branch, and then run the tests/code coverage again. The above process happens repeatedly for every code commit and thereby continuously integrates the new code changes into the existing software.</p>\n<h5>Continuous Delivery</h5>\n<p>Although the continuous integration process ensures that the code in the master branch is always pristine and well-tested, it cannot help catch usability issues. A QA team and other stakeholders are usually responsible for usability and acceptance testing.</p>\n<p>A successful exit from the CI process triggers the continuous delivery process and delivers the software system to a QA staging area. The QA environment usually closely resembles the production environment but with less redundancy. The continuous delivery process can have a mixed bag of automated and manual usability/acceptance testing phases.</p>\n<p>While continuous delivery provides a process to create frequent releases, the releases may not be deployed at all times.</p>\n<h5>Continuous Deployment</h5>\n<p>In case of continuous deployment, every change that is made to the code gets deployed to production, unless tests fail the process. This process is highly automated with new code built, tested, versioned, tagged and deployed to the production environment.</p>\n<p>In a special scenario, where major bugs and issues are found in a recently deployed version of the software, a “rollback” can be initiated. A rollback process takes a previous release version and delivers it to the production environment. This process can be automated but is usually manually triggered.</p>\n<h4>Application Testing</h4>\n<p>Now that we’ve gone over some basics, let’s get started!</p>\n<p>For this project, we’ll use a serverless app, <code class=\"language-text\">hello-world-ci</code>, which I created using the <code class=\"language-text\">hello-world</code> template from the Serverless Framework. We’ll keep the app very simple so that we can focus on the CI process.</p>\n<p>You can install the sample app from the <a href=\"https://github.com/rupakg/hello-world-ci\">source repo</a> using the Serverless Framework, like so:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sls install --url https://github.com/rupakg/hello-world-ci</code></pre></div>\n<p>Having proper tests in place safeguards against subsequent code updates. We’d like to run tests and code coverage against our code. If the tests pass, we’ll deploy our app.</p>\n<p>It’s this—running tests against our code whenever new code is committed—that allows for continuous integration.</p>\n<h5>Testable Code</h5>\n<p>We have some <a href=\"https://github.com/rupakg/hello-world-ci/blob/master/tests/hello-world.spec.js\">tests</a> that we’ll run as part of the testing phase. Notice that we have a spec that tests if our function is being called.</p>\n<p>We are also separating out the actual testable logic of our function into a class:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// lib/hello-world.js</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">HelloWorld</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n            message<span class=\"token operator\">:</span> <span class=\"token string\">'Go Serverless v1.0! Your function executed successfully!'</span><span class=\"token punctuation\">,</span>\n            input<span class=\"token operator\">:</span> event<span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> HelloWorld<span class=\"token punctuation\">;</span></code></pre></div>\n<p>The <code class=\"language-text\">handler.js</code> code is refactored to use the above <code class=\"language-text\">sayHello</code> method from the <code class=\"language-text\">HelloWorld</code> class:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// handler.js</span>\n\nmodule<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">helloWorld</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> callback</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">var</span> hWorld <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HelloWorld</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    statusCode<span class=\"token operator\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span>\n    headers<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token string\">'Access-Control-Allow-Origin'</span><span class=\"token operator\">:</span> <span class=\"token string\">'*'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// Required for CORS support to work</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    body<span class=\"token operator\">:</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>hWorld<span class=\"token punctuation\">.</span><span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This makes testing the core logic of the app easy and also decouples it from the provider-specific function signature.</p>\n<h5>Running Tests</h5>\n<p>Now that we’ve got our tests written up, let’s run them locally before we include them as part of our CI/CD process.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> <span class=\"token builtin class-name\">test</span> --coverage</code></pre></div>\n<p>The tests results looks like this on the terminal:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&gt; hello-world-ci@1.0.0 test /Users/rupakg/projects/svrless/apps/hello-world-ci\n&gt; jest\n\n PASS  tests/hello-world.spec.js\n  helloWorld\n    ✓ should call helloWorld function with success (9ms)\n  sayHello\n    ✓ should call sayHello and return message (1ms)\n\nTest Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        0.627s, estimated 1s\nRan all test suites.</code></pre></div>\n<p>The code coverage looks like this in the terminal:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">--------------------<span class=\"token operator\">|</span>----------<span class=\"token operator\">|</span>----------<span class=\"token operator\">|</span>----------<span class=\"token operator\">|</span>----------<span class=\"token operator\">|</span>----------------<span class=\"token operator\">|</span>\nFile                <span class=\"token operator\">|</span>  % Stmts <span class=\"token operator\">|</span> % Branch <span class=\"token operator\">|</span>  % Funcs <span class=\"token operator\">|</span>  % Lines <span class=\"token operator\">|</span>Uncovered Lines <span class=\"token operator\">|</span>\n--------------------<span class=\"token operator\">|</span>----------<span class=\"token operator\">|</span>----------<span class=\"token operator\">|</span>----------<span class=\"token operator\">|</span>----------<span class=\"token operator\">|</span>----------------<span class=\"token operator\">|</span>\nAll files           <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>                <span class=\"token operator\">|</span>\n hello-world-ci     <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>                <span class=\"token operator\">|</span>\n  handler.js        <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>                <span class=\"token operator\">|</span>\n hello-world-ci/lib <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>                <span class=\"token operator\">|</span>\n  hello-world.js    <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>      <span class=\"token number\">100</span> <span class=\"token operator\">|</span>                <span class=\"token operator\">|</span>\n--------------------<span class=\"token operator\">|</span>----------<span class=\"token operator\">|</span>----------<span class=\"token operator\">|</span>----------<span class=\"token operator\">|</span>----------<span class=\"token operator\">|</span>----------------<span class=\"token operator\">|</span></code></pre></div>\n<p>We also get an HTML page with the code coverage results depicted visually, like so:</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/cicd/jest-code-coverage.png\" alt=\"Visual Code Coverage Results\"></p>\n<p><em>Figure 2: Visual code coverage results</em></p>\n<h5>Excluding Testing Artifacts</h5>\n<p>After running the tests, you should see that a <code class=\"language-text\">coverage</code> folder has been created. This holds the files that are generated by Jest. You’ll also have a <code class=\"language-text\">.circleci</code> folder—that one is required to enable build automation with CircleCI.</p>\n<p>When we deploy our serverless app via the Serverless Framework, all the files in your current folder will be zipped up and part of the deployment to AWS.</p>\n<p>Since the <code class=\"language-text\">coverage</code> and <code class=\"language-text\">.circleci</code> files are not necessary for running our app, let’s exclude them from our final deployment by excluding them in our <code class=\"language-text\">serverless.yml</code> file:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">service: hello-world-ci\n\n# exclude the code coverage files and circle ci files\npackage:\n  exclude:\n  - coverage/**\n  - .circleci/**</code></pre></div>\n<blockquote>\n<p>See more details on <a href=\"https://serverless.com/framework/docs/providers/aws/guide/packaging\">packaging options</a> with the Serverless Framework.</p>\n</blockquote>\n<h4>Preparing for CI Automation</h4>\n<p>We’ll be using <a href=\"https://circleci.com\">CircleCI</a> for automating the CI/CD pipeline for our <code class=\"language-text\">hello-world-ci</code> app.</p>\n<p>Let’s get everything ready to go.</p>\n<h5>Setting up a CircleCI Account</h5>\n<p><a href=\"https://circleci.com/docs/2.0/first-steps/\">Sign up</a> for a CircleCI account if you don’t already have one. As part of the sign-up process, we’ll authorize CircleCI to access our public Github repo so that it can run builds.</p>\n<h5>Creating an AWS IAM User</h5>\n<p>It is a good practice to have a separate IAM user just for the CI build process. We’ll create a new IAM user called <code class=\"language-text\">circleci</code> in the AWS console. Give the user programmatic access and save the AWS credentials, which we’ll use later to configure our project in CircleCI.</p>\n<p><strong>Note:</strong> More on <a href=\"https://serverless.com/blog/abcs-of-iam-permissions/\">setting up IAM users here</a>.</p>\n<h5>Configuring CircleCI with AWS Credentials</h5>\n<p>We have to configure AWS credentials with CircleCI in order to deploy our app to AWS.</p>\n<p>Go to your project <code class=\"language-text\">hello-world-ci</code> -> Project Settings -> AWS Permissions, and add your AWS credentials for the <code class=\"language-text\">circleci</code> IAM user we created earlier.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/cicd/circleci-aws-perms.png\" alt=\"Adding AWS credentials\"></p>\n<p><em>Figure 3: Adding AWS credentials</em></p>\n<h4>End-to-End Automation</h4>\n<p>Now that we’ve completed our CircleCI setup, let’s work on implementing the CI/CD workflow for our project.</p>\n<h5>Configuration</h5>\n<p>We’ll configure CircleCI via a config file named <code class=\"language-text\">config.yml</code> and keep it in the <code class=\"language-text\">.circleci</code> directory. Explanation of how CircleCI works is out of scope for this article, but we’ll look at the steps needed to automate our deployments.</p>\n<blockquote>\n<p>If you want some further reading, CircleCI introduces concepts of <a href=\"https://circleci.com/docs/2.0/sample-config/#jobs-overview\">Jobs</a>, <a href=\"https://circleci.com/docs/2.0/sample-config/#steps-overview\">Steps</a> and <a href=\"https://circleci.com/docs/2.0/workflows/\">Workflows</a>.</p>\n</blockquote>\n<p>To keep things simple and get started, we’ll use a simple configuration wherein everything we do will be in one job and under one step. CircleCI allows for multiple jobs with multiple steps all orchestrated via a workflow.</p>\n<p>Here is a snippet of the config file that we’ll use:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">jobs:\n  build:\n    ...\n\n    steps:\n      - checkout\n\n      # Download and cache dependencies\n      - restore_cache:\n          keys:\n            - dependencies-cache-{{ checksum &quot;package.json&quot; }}\n            # fallback to using the latest cache if no exact match is found\n            - dependencies-cache\n\n      - run:\n          name: Install Serverless CLI and dependencies\n          command: |\n            sudo npm i -g serverless\n            npm install\n\n      - run:\n          name: Run tests with code coverage\n          command: npm test --coverage\n\n      - run:\n          name: Deploy application\n          command: sls deploy\n\n      - save_cache:\n          paths:\n            - node_modules\n          key: dependencies-cache-{{ checksum &quot;package.json&quot; }}</code></pre></div>\n<p>We have a <code class=\"language-text\">job</code> named <code class=\"language-text\">build</code>, and we have a few <code class=\"language-text\">steps</code>. The <code class=\"language-text\">checkout</code> step will check out the files from the attached source repo. We also have a few <code class=\"language-text\">run</code> steps that just execute bash commands.</p>\n<p>We’ll install the serverless cli and the project dependencies, then run our tests with code coverage enabled, and finally deploy the application.</p>\n<p><strong>Note</strong>: The <code class=\"language-text\">save_cache</code> and <code class=\"language-text\">restore_cache</code> sections in the above config file, allows for caching the <code class=\"language-text\">node_modules</code> between builds, as long as the <code class=\"language-text\">package.json</code> file has not changed. It significantly reduces build times.</p>\n<p><strong>Note</strong>: You can review the full <a href=\"https://github.com/rupakg/hello-world-ci/blob/master/.circleci/config.yml\">config file</a> for our app. And you can review a full CircleCI <a href=\"https://circleci.com/docs/2.0/sample-config/\">sample configuration</a> file with more options as well.</p>\n<h5>Implementing the Workflow</h5>\n<p>To add our app project to CircleCI, do the following:</p>\n<ul>\n<li>Push the local app from your machine to your Github account or fork the <a href=\"https://github.com/rupakg/hello-world-ci\">sample project</a> on your Github account.</li>\n<li>Go to Projects -> Add Projects, and click the ‘Setup project’ button next to your project. Make sure the ‘Show forks’ checkbox is checked.</li>\n<li>\n<p>Since we have our CircleCI config file already placed at the root of our project, some of the configuration is picked up automatically:</p>\n<ul>\n<li>Pick ‘Linux’ as the Operating System.</li>\n<li>Pick ‘2.0’ as the Platform.</li>\n<li>Pick ‘Node’ as the Language.</li>\n</ul>\n</li>\n<li>Skip steps 1-4. Click on ‘Start building’.</li>\n</ul>\n<p>You’ll see the system running the build for your project.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/cicd/circleci-building.png\" alt=\"Build running on CircleCI\"></p>\n<p><em>Figure 4: Build running on CircleCI</em></p>\n<p>You can drill down to see the steps on the UI that matches our steps in the config file. While it is executing each step, you can see the activity.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/cicd/circleci-steps.png\" alt=\"Build steps for the project\"></p>\n<p><em>Figure 5: Build steps for the project</em></p>\n<p>You can see the tests running as part of the ‘Run tests with code coverage’ step.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/cicd/circleci-tests.png\" alt=\"Running tests for the project\"></p>\n<p><em>Figure 6: Running tests for the project</em></p>\n<p>And finally, you see that our app has been deployed under the ‘Deploy application’ step.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/cicd/circleci-success-1.png\" alt=\"Deploying the project\">\n<img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/cicd/circleci-success-2.png\" alt=\"Deploying the project\"></p>\n<p><em>Figure 7: Deploying the project</em></p>\n<p>Last but not least, we can copy the endpoint shown in the output onto a browser and see the app run!</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/cicd/circleci-deployed-app.png\" alt=\"Running the app\"></p>\n<p><em>Figure 8: Running the app</em></p>\n<p>Hopefully, the full rundown of the process and its implementation on a CI/CD platform such as CircleCI gives you a better understanding of automating your own applications.</p>\n<h4>Advanced Deployment Patterns</h4>\n<p>In real-life enterprise scenarios, there’s a lot of complexity involved in deploying an application. There are concerns about redundancy, high-availability, versioning &#x26; rollback, A/B testing and incremental rollouts.</p>\n<p>All of this needs to be achieved without sacrificing the flexibility &#x26; ease of the deployment process, and at the same time keeping the customer happy.</p>\n<p>In this section, we’ll look at some of these concerns and ways the Serverless Framework can help solve it.</p>\n<h5>Multi-region Deployments</h5>\n<p>A popular pattern for introducing redundancy and achieving high-availability is to deploy your application into multiple regions. In our use case, we will deploy our application to two AWS regions - <code class=\"language-text\">us-east-1</code> and <code class=\"language-text\">us-east-2</code>.</p>\n<p><strong>Note</strong>: It is more complex to do multi-region deployments when databases are involved, as you need to take care of replicating and syncing data across multiple regions. A DNS service like AWS Route 53 with domain mappings would have to be put in place to maintain high availability.</p>\n<h5>Multiple Deploys</h5>\n<p>We can start off with a simple workflow using the <a href=\"https://serverless.com/framework/\">Serverless Framework</a>. Using the framework, we can execute multiple <code class=\"language-text\">sls deploy</code> commands targeting a particular region.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ sls deploy --stage qa --region us-east-1\n\n$ sls deploy --stage qa --region us-east-2</code></pre></div>\n<p>Although this method for deploying to multi-region is simple, it poses a challenge. Since there are two different commands, the Serverless Framework packages &#x26; deploys the app twice. It’s practically impossible to make sure that the exact same copy of the code has been deployed.</p>\n<h5>Separating Packaging and Deployment</h5>\n<p>Keeping the above challenge in mind, the Serverless Framework provides an advanced workflow for deploying to multiple regions. It provides a way to separate the <strong>packaging</strong> and <strong>deploying</strong> portions of the overall deploy process.</p>\n<p>The Serverless Framework provides a <code class=\"language-text\">sls package</code> command to package code and then allows you to use that package in the <code class=\"language-text\">sls deploy</code> command to deploy it.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># package the code once\n$ sls package --package &lt;path_to_package&gt;\n\n# deploy the same package to multiple regions\n$ sls deploy --package &lt;path_to_package&gt; --stage qa \\\n             --region us-east-1\n\n$ sls deploy --package &lt;path_to_package&gt; --stage qa \\\n             --region eu-central-1\n\n$ sls deploy --package &lt;path_to_package&gt; --stage qa \\\n             --region eu-west-1</code></pre></div>\n<blockquote>\n<p>The Serverless Framework allows the convenience for applications to be <strong>packaged once</strong> and <strong>deployed multiple times</strong>.</p>\n</blockquote>\n<p>Let’s look at the implementation of this deployment pattern and ways we can automate it.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/cicd/cloudcraft-adv-deployment.png\" alt=\"Separating packaging and deployment\"></p>\n<p><em>Figure 9: Separating packaging and deployment</em></p>\n<p>Here are the details of the workflow:</p>\n<ol>\n<li>A step in the CI process packages the app code into a package and uploads it to a S3 bucket. This S3 bucket could be a generic storage for all deployment packages. The CI process uses the <code class=\"language-text\">sls package</code> command to package the app code.</li>\n<li>An S3 event triggers a Lambda function, that takes the package and uploads it to separate S3 buckets in multiple regions.</li>\n<li>The S3 instances in each region, then trigger another Lambda function, that deploys the package to that particular region. The Lambda functions use <code class=\"language-text\">sls deploy</code> passing it the package to deploy.</li>\n</ol>\n<blockquote>\n<p>The Serverless Framework provides an easy &#x26; automated way to deploy serverless applications across multiple regions for adding redundancy and achieving high-availability.</p>\n</blockquote>\n<h4>Canary Deployments</h4>\n<p>Another popular deployment pattern is <strong>canary</strong> deployments. Canary releases are used to reduce risk when releasing new software versions.</p>\n<p>The pattern lays down a workflow that enables the slow and incremental rollout of new versions by gating it to a small subset of end users. Once the new software version has been tested to be satisfactory for mass consumption, the release is opened to all user traffic.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/cicd/canary-deployment.gif\" alt=\"Canary deployment flow\"></p>\n<p><em>Figure 10: Canary deployment flow</em></p>\n<p>Here are the details of the flow:</p>\n<ol>\n<li><strong>Current State</strong>: Imagine a current state of the environment where an existing version of the software is running in an isolated region. All user traffic is redirected to this environment (denoted by the gray box).</li>\n<li><strong>Canary State</strong>: Next, a new version of the software is ready to be tested and deployed. This new version will be deployed to another isolated region. To test the new version, a subset of user traffic (5% in our case) is redirected to the new environment (denoted by the blue box).</li>\n<li><strong>End State</strong>: Once the testing is complete and the results are found to be satisfactory, all user traffic is redirected to the new environment with the new version of the software.</li>\n<li><strong>Rollback State</strong>: Unfortunately, sometimes serious bugs are discovered in the new version and code have to be rolled back. In this scenario, all user traffic is redirected back to the old version of the software (denoted by the gray box).</li>\n</ol>\n<p>After a certain amount of time that the new version of the software has been live, the old environment with the old version can be taken down.</p>\n<p>An off-shoot use case of canary deployment pattern is, using it for A/B testing as well. In case of A/B testing scenarios, tweaking the amount of user traffic gives the developers a good idea of the performance and usability of each individual version of the software.</p>\n<blockquote>\n<p>Canary deployments are used to reduce the risk of releasing new software versions by incremental rollouts with gated user traffic. They are also used to perform A/B testing.</p>\n</blockquote>\n<p><strong>Update</strong>: AWS announced <a href=\"https://serverless.com/blog/ultimate-list-serverless-announcements-reinvent/#canary-management-for-api-gateway\">API Gateway support for canary deployments</a> at AWS re:Invent 2017.</p>\n<h4>Blue/Green Deployments</h4>\n<p>Yet another deployment pattern in use is the <strong>blue/green</strong> deployment. The blue/green deployment pattern is very similar to canary deployments—but instead of gating user traffic, two separate identical environments are used in parallel to mitigate risks of introducing new software versions.</p>\n<p>One environment is used for go-live, and the other is used for staging new changes. The workflow dictates switching environments back and forth between staging and live.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/cicd/blue-green-deployment.gif\" alt=\"Blue/Green deployment flow\"></p>\n<p><em>Figure 11: Blue/Green deployment flow</em></p>\n<p>Here are the details of the flow:</p>\n<ol>\n<li><strong>Live (blue)</strong>: Initially, the current version of the software is deployed to the blue environment with the all user traffic being redirected to the blue environment.</li>\n<li><strong>Staging to Live (green)</strong>: After a new version of the software is developed, it is deployed to the staging environment (green) for testing. After the testing of the new version of the software is considered satisfactory, all traffic is redirected to the green environment and the green environment is considered as live.</li>\n<li><strong>Live to Staging (blue)</strong>: Since the green environment is now the live version, the blue environment is considered staging. The new version of the code is deployed to the blue environment for testing.</li>\n<li><strong>Rollback scenario</strong>: Unfortunately, sometimes serious bugs are discovered in the new version (blue) and code have to be rolled back. In this case, all traffic is redirected back to the blue environment. The blue environment is back being the live version. The green environment becomes staging.</li>\n</ol>\n<h4>Routing Mechanics</h4>\n<p>The traffic routing is done by setting up a DNS service (AWS Route 53) in front of the API Gateway.</p>\n<p>In the case of canary deployments, AWS Route 53 is switched from ‘simple routing’ to ‘weighted routing’ to achieve a percentage mix of user traffic between environments. In case of blue/green deployments, the ‘weighted routing’ is toggled between 0% and 100% across the blue/green environments.</p>\n<h4>Benefits of Serverless</h4>\n<p>In traditional architectures, the canary and blue/green deployments are used after a lot of consideration and planning. The reason being, there’s a high cost to provisioning hardware and maintaining multiple environments required in order to realize the potential of such deployment patterns.</p>\n<p>The benefits of embracing serverless architectures are immediately evident here—it means no provisioning or maintenance costs for multiple environments. On top of that, the fact that serverless is pay-per-execution reduces execution costs significantly; you never pay for any idle infrastructure, in any environment.</p>\n<blockquote>\n<p>Advanced deployment patterns like canary and blue/green deployments are practically <strong>feasible</strong>, more <strong>cost-effective</strong> and <strong>easily managed</strong> when used with serverless architectures.</p>\n</blockquote>\n<h4>Quick summary</h4>\n<p>In this post, we looked at the overall CI/CD process flow, detailing each process step. We then created a serverless application and refactored the code to be testable.</p>\n<p>We then ran the tests and code coverage locally to make sure our code was working. Once we had our app running locally, we set up an automated CI workflow for our app on CircleCI.</p>\n<p>At the end of the post, we looked at some of the more complex deployment patterns and how serverless architectures could help make them more cost-effective &#x26; feasible.</p>\n<p>Any comments or questions? Drop them below!</p>","frontmatter":{"title":"Automating CI/CD workflow for serverless apps with CircleCI","date":"December 07, 2017","description":"There are big benefits to using serverless architectures in continuous integration & deployment (CI/CD) processes. We'll show you why, and how to do it."}}},"pageContext":{"slug":"/posts/2017-12-06-ci-cd-workflow-serverless-apps-with-circleci/","previous":{"fields":{"slug":"/posts/2017-12-06-introducing-openevents/"},"frontmatter":{"title":"Introducing OpenEvents"}},"next":{"fields":{"slug":"/posts/2017-12-12-automatic-dynamodb-backups-serverless/"},"frontmatter":{"title":"Automate your DynamoDB backups with Serverless in less than 5 minutes"}}}}}