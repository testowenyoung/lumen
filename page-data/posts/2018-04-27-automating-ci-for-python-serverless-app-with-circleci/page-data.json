{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2018-04-27-automating-ci-for-python-serverless-app-with-circleci/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"70d23cb1-ad40-5bac-a411-bb96bd671464","excerpt":"I had previously written a post that defined the CI/CD process, discussed various deployment patterns, created a NodeJS app, and automated the end-to-end CI…","html":"<p>I had previously written <a href=\"https://serverless.com/blog/ci-cd-workflow-serverless-apps-with-circleci/\">a post that defined the CI/CD process</a>, discussed various deployment patterns, created a NodeJS app, and automated the end-to-end CI flow.</p>\n<p>In this post, I will be doing that same thing for Python. We’ll build a Python app and go over the end-to-end process for automating the CI flow.</p>\n<p>We will cover:</p>\n<ul>\n<li>Creating a Python app</li>\n<li>Writing testable code</li>\n<li>Preparing for CI automation</li>\n<li>Implementing the CI workflow</li>\n</ul>\n<p>But first, I’ll do a quick overview of the CI/CD process. If you already know some CI/CD basics, then you’ll probably want to skip straight to <a href=\"#creating-the-app\">creating the app</a>.</p>\n<h1>CI/CD Overview</h1>\n<p>In an agile development environment, small teams work autonomously and add a lot of churn to the code base. Each developer works on different aspects of the project and frequently commits code.</p>\n<p>This is a healthy practice, but it comes with some challenges. Without close watch and proper communication about changes, the updates can cause existing code to break. To minimize manual scrutiny and redundant communication across teams, we need to invest in automating CI/CD processes.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/cicd/cicd-process.gif\" alt=\"The CI/CD Process Flow\"></p>\n<p><em>The CI/CD Process Flow</em></p>\n<h2>Continuous Integration</h2>\n<p>The CI process starts with the developer checking code into a code repository. The developer makes their code changes in a local branch, then adds units tests and integration tests. They ensure that the tests don’t lower the overall code coverage. It’s possible to automate this process by having a common script that can run the unit tests, integration tests, and code coverage.</p>\n<p>Once the code is tested in the context of the local branch, the developer needs to merge the master branch into their local branch, and then run the tests/code coverage again. The above process happens repeatedly for every code commit, and thereby continuously integrates the new code changes into the existing codebase.</p>\n<h1>Creating the app</h1>\n<p>Now that we’ve gone over some basics, let’s get started!</p>\n<p><strong>Note:</strong> We won’t be covering the basics of creating a serverless Python app, but you can get an idea by reading <a href=\"https://serverless.com/blog/etl-job-processing-with-serverless-lambda-and-redshift/\">this post about ETL job processing</a>.</p>\n<p>Let’s cut to the chase and install the sample app from the <a href=\"https://github.com/rupakg/python-ci\">source repo</a> using the Serverless Framework like so:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ sls <span class=\"token function\">install</span> --url https://github.com/rupakg/python-ci\n$ <span class=\"token builtin class-name\">cd</span> python-ci</code></pre></div>\n<p>Having proper tests in place safeguards against subsequent code updates. We’d like to run tests and code coverage against our code. If the tests pass, we’ll deploy our app.</p>\n<p>It’s this—running tests against our code whenever new code is committed—that allows for continuous integration.</p>\n<h1>Testable Code</h1>\n<p><a href=\"https://github.com/rupakg/python-ci/blob/master/tests/test_helloworld.py\">We have some tests</a> that we’ll run as part of the testing phase. Notice that we have a test that tests if our function is being called.</p>\n<p>We are also separating out the actual testable logic of our function into a class:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># hw/helloworld.py</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">HelloWorld</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">say_hello</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token string\">\"message\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"Go Serverless v1.0! Your function executed successfully!\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"input\"</span><span class=\"token punctuation\">:</span> event\n        <span class=\"token punctuation\">}</span></code></pre></div>\n<p>The <code class=\"language-text\">handler.py</code> code is refactored to use the above <code class=\"language-text\">say_hello</code> method from the <code class=\"language-text\">HelloWorld</code> class:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># handler.py</span>\n\n<span class=\"token keyword\">from</span> hw<span class=\"token punctuation\">.</span>helloworld <span class=\"token keyword\">import</span> HelloWorld\n<span class=\"token keyword\">import</span> json\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">hello_world</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    world <span class=\"token operator\">=</span> HelloWorld<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    response <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token string\">\"statusCode\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"body\"</span><span class=\"token punctuation\">:</span> json<span class=\"token punctuation\">.</span>dumps<span class=\"token punctuation\">(</span>world<span class=\"token punctuation\">.</span>say_hello<span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> response</code></pre></div>\n<p>This makes testing the core logic of the app easy, and also decouples it from the provider-specific function signature.</p>\n<h2>Running Tests</h2>\n<p>Now that our tests are written up, let’s run them locally before we include them as part of our CI/CD process.</p>\n<p>For running tests we will use <a href=\"https://nose.readthedocs.io/en/latest/\">nose</a>. We add the <code class=\"language-text\">--with-coverage</code> flag to run the test with code coverage. (Remember, you will need <a href=\"https://coverage.readthedocs.io/en/coverage-4.5.1/\">coverage.js</a> installed to use coverage.)</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ nosetests --with-coverage</code></pre></div>\n<p>The tests results look like this in the terminal:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">..</span>\nName               Stmts   Miss  Cover\n--------------------------------------\nhandler.py             <span class=\"token number\">6</span>      <span class=\"token number\">0</span>   <span class=\"token number\">100</span>%\nhw/__init__.py         <span class=\"token number\">0</span>      <span class=\"token number\">0</span>   <span class=\"token number\">100</span>%\nhw/helloworld.py       <span class=\"token number\">3</span>      <span class=\"token number\">0</span>   <span class=\"token number\">100</span>%\n_bootlocale.py        <span class=\"token number\">17</span>     <span class=\"token number\">17</span>     <span class=\"token number\">0</span>%\n--------------------------------------\nTOTAL                 <span class=\"token number\">26</span>     <span class=\"token number\">17</span>    <span class=\"token number\">35</span>%\n----------------------------------------------------------------------\nRan <span class=\"token number\">2</span> tests <span class=\"token keyword\">in</span> <span class=\"token number\">0</span>.061s\n\nOK</code></pre></div>\n<p>Alternatively, you could also run code coverage with the <code class=\"language-text\">--cover-html</code> flag to get a nice visual chart of the code coverage as shown below:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ nosetests --with-coverage --cover-html</code></pre></div>\n<p>The above command creates an html representation of the coverage metrics in the default folder <code class=\"language-text\">cover</code>, and looks like so:</p>\n<p><img src=\"https://user-images.githubusercontent.com/8188/39218547-48cb51b6-47f3-11e8-9186-c828b75df567.png\" alt=\"Coverage\"></p>\n<h2>Excluding Testing Artifacts</h2>\n<p>After running the tests, you should see that a <code class=\"language-text\">.coverage</code> folder has been created. If you run the visual code coverage command, the <code class=\"language-text\">cover</code> folder will be created as well. You’ll also have a <code class=\"language-text\">.circleci</code> folder—that one is required to enable build automation with CircleCI.</p>\n<p>When we deploy our serverless app via the Serverless Framework, all the files in your current folder will be zipped up and be part of the deployment to AWS.</p>\n<p>Since the <code class=\"language-text\">coverage</code>, <code class=\"language-text\">cover</code>, and <code class=\"language-text\">.circleci</code> files are not necessary for running our app, let’s exclude them from our final deployment by excluding them in our <code class=\"language-text\">serverless.yml</code> file:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># exclude the code coverage files and circle ci files</span>\n<span class=\"token key atrule\">package</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">exclude</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> .coverage\n  <span class=\"token punctuation\">-</span> cover/<span class=\"token important\">**</span>\n  <span class=\"token punctuation\">-</span> .circleci/<span class=\"token important\">**</span></code></pre></div>\n<p><strong>Note:</strong> See more details on <a href=\"https://serverless.com/framework/docs/providers/aws/guide/packaging\">packaging options</a> with the Serverless Framework.</p>\n<h1>Preparing for CI Automation</h1>\n<p>We’ll be using <a href=\"https://circleci.com\">CircleCI</a> for automating the CI/CD pipeline for our <code class=\"language-text\">python-ci</code> app.</p>\n<p>Let’s get everything ready to go.</p>\n<h2>Setting up a CircleCI Account</h2>\n<p><a href=\"https://circleci.com/docs/2.0/first-steps/\">Sign up</a> for a CircleCI account if you don’t already have one. As part of the sign-up process, we’ll authorize CircleCI to access our public Github repo so that it can run builds.</p>\n<h2>Creating an AWS IAM User</h2>\n<p>It is a good practice to have a separate IAM user just for the CI build process. We’ll create a new IAM user called <code class=\"language-text\">circleci</code> in the AWS console. Give the user programmatic access and save the AWS credentials, which we’ll use later to configure our project in CircleCI.</p>\n<p><strong>Note:</strong> More on <a href=\"https://serverless.com/blog/abcs-of-iam-permissions/\">setting up IAM users here</a>.</p>\n<h2>Configuring CircleCI with AWS Credentials</h2>\n<p>We have to configure AWS credentials with CircleCI in order to deploy our app to AWS.</p>\n<p>Go to your project <code class=\"language-text\">python-ci</code> -> Project Settings -> AWS Permissions, and add your AWS credentials for the <code class=\"language-text\">circleci</code> IAM user we created earlier.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/cicd/circleci-aws-perms.png\" alt=\"Adding AWS credentials\"></p>\n<h1>End-to-End Automation</h1>\n<p>Now that we’ve completed our CircleCI setup, let’s work on implementing the CI/CD workflow for our project.</p>\n<h2>Configuration</h2>\n<p>We’ll configure CircleCI via a config file named <code class=\"language-text\">config.yml</code> and keep it in the <code class=\"language-text\">.circleci</code> directory. Explanation of how CircleCI works is out of scope for this article, but we’ll look at the steps needed to automate our deployments.</p>\n<p><strong>Note:</strong> If you want some further reading, CircleCI introduces concepts of <a href=\"https://circleci.com/docs/2.0/sample-config/#jobs-overview\">Jobs</a>, <a href=\"https://circleci.com/docs/2.0/sample-config/#steps-overview\">Steps</a> and <a href=\"https://circleci.com/docs/2.0/workflows/\">Workflows</a>.</p>\n<p>CircleCI allows for multiple jobs with multiple steps, all orchestrated via a workflow. But to keep things simple, we’re going to keep everything within one job and one step.</p>\n<p>Here is a snippet of the config file that we’ll use:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># Javascript Node CircleCI 2.0 configuration file</span>\n\n<span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span>\n<span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">working_directory</span><span class=\"token punctuation\">:</span> ~/python<span class=\"token punctuation\">-</span>ci\n\n    <span class=\"token key atrule\">docker</span><span class=\"token punctuation\">:</span>\n      <span class=\"token comment\"># specify the version you desire here</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> circleci/python<span class=\"token punctuation\">:</span>3.6.1\n\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> checkout\n\n      <span class=\"token comment\"># Download and cache dependencies</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">restore_cache</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">keys</span><span class=\"token punctuation\">:</span>\n            <span class=\"token punctuation\">-</span> dependencies<span class=\"token punctuation\">-</span>node<span class=\"token punctuation\">-</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> checksum \"package.json\" <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n            <span class=\"token comment\"># fallback to using the latest cache if no exact match is found</span>\n            <span class=\"token punctuation\">-</span> dependencies<span class=\"token punctuation\">-</span>node\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Install python test dependencies\n          <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n            sudo pip install nose\n            sudo pip install coverage</span>\n\n      <span class=\"token comment\"># this is slow. build a custom docker image and use that</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Install node and npm\n          <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n            curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -\n            sudo apt-get install -y nodejs\n            node --version &amp;&amp; npm -v</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Install Serverless CLI and dependencies\n          <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n            sudo npm i -g serverless\n            npm install</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">save_cache</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">paths</span><span class=\"token punctuation\">:</span>\n            <span class=\"token punctuation\">-</span> node_modules\n          <span class=\"token key atrule\">key</span><span class=\"token punctuation\">:</span> dependencies<span class=\"token punctuation\">-</span>node<span class=\"token punctuation\">-</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> checksum \"package.json\" <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\"># run tests</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Run tests with code coverage\n          <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n            nosetests --with-coverage</span>\n\n      <span class=\"token comment\"># deploy app</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Deploy application\n          <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> sls deploy <span class=\"token punctuation\">-</span>v</code></pre></div>\n<p>We have a <code class=\"language-text\">job</code> named <code class=\"language-text\">build</code>, and we have a few <code class=\"language-text\">steps</code>. The <code class=\"language-text\">checkout</code> step will check out the files from the attached source repo. We also have a few <code class=\"language-text\">run</code> steps that just execute bash commands.</p>\n<p>We’ll install the serverless CLI and the project dependencies, run our tests with code coverage enabled, and finally deploy the application.</p>\n<p><strong>Note 1</strong>: The <code class=\"language-text\">save_cache</code> and <code class=\"language-text\">restore_cache</code> sections in the above config file allow for caching the <code class=\"language-text\">node_modules</code> between builds, as long as the <code class=\"language-text\">package.json</code> file has not changed. It significantly reduces build times.</p>\n<p><strong>Note 2</strong>: You can review the <a href=\"https://github.com/rupakg/python-ci/blob/master/.circleci/config.yml\">full config file</a> for our app. And you can review a <a href=\"https://circleci.com/docs/2.0/sample-config/\">full CircleCI sample configuration</a> file with more options as well.</p>\n<h1>Implementing the Workflow</h1>\n<p>To add our app project to CircleCI, do the following:</p>\n<ul>\n<li>Push the local app from your machine to your Github account, or fork the <a href=\"https://github.com/rupakg/python-ci\">sample project</a> on your Github account.</li>\n<li>Go to Projects -> Add Projects, and click the ‘Setup project’ button next to your project. Make sure the ‘Show forks’ checkbox is checked.</li>\n<li>\n<p>Since we have our CircleCI config file already placed at the root of our project, some of the configuration is picked up automatically:</p>\n<ul>\n<li>Pick ‘Linux’ as the Operating System.</li>\n<li>Pick ‘2.0’ as the Platform.</li>\n<li>Pick ‘Node’ as the Language.</li>\n</ul>\n</li>\n<li>Skip steps 1-4. Click on ‘Start building’.</li>\n</ul>\n<p>You’ll see the system running the build for your project:</p>\n<p><img src=\"https://user-images.githubusercontent.com/8188/39228988-c70201a2-482e-11e8-8a83-895eb5d421e7.png\" alt=\"Build running on CircleCI\"></p>\n<p>You can drill down to see the steps on the UI that matches our steps in the config file. While it is executing each step, you can see the activity:</p>\n<p><img src=\"https://user-images.githubusercontent.com/8188/39228726-8b7bb6c4-482d-11e8-9127-b7e18ce61d9b.png\" alt=\"Build steps for the project\"></p>\n<p>You can see the tests running as part of the ‘Run tests with code coverage’ step:</p>\n<p><img src=\"https://user-images.githubusercontent.com/8188/39228801-e282d06a-482d-11e8-9f10-14c7e26f0860.png\" alt=\"Running tests for the project\"></p>\n<p>And finally, you see that our app has been deployed under the ‘Deploy application’ step:</p>\n<p><img src=\"https://user-images.githubusercontent.com/8188/39229393-9f357bca-4830-11e8-81c1-4249cc0d4806.png\" alt=\"Deploying the project\">\n<img src=\"https://user-images.githubusercontent.com/8188/39229433-c7be2146-4830-11e8-8dcb-eee0284125ec.png\" alt=\"Deploying the project\"></p>\n<p>Last but not least, we can copy the endpoint shown in the output onto a browser and see the app run!</p>\n<p><img src=\"https://user-images.githubusercontent.com/8188/39229232-dc4b6502-482f-11e8-88f4-085ce5bfd832.png\" alt=\"Running the app\"></p>\n<p>Hopefully, the full rundown of the process and its implementation on a CI/CD platform such as CircleCI gives you a better understanding of automating your own applications.</p>\n<h1>Summary</h1>\n<p>In this post, we looked at the overall CI/CD process flow, and created a serverless application in Python.</p>\n<p>We refactored the code to be testable, then ran the tests and code coverage locally to make sure our code was working. Once we had our app running locally, we set up an automated CI workflow for our app on CircleCI.</p>\n<p>Any comments or questions? Drop them below!</p>","frontmatter":{"title":"Automating a CI workflow for a Python serverless app with CircleCI","date":"April 27, 2018","description":"An end-to-end look at continuous integration with Python, Serverless and CircleCI."}}},"pageContext":{"slug":"/posts/2018-04-27-automating-ci-for-python-serverless-app-with-circleci/","previous":{"fields":{"slug":"/posts/2018-04-25-what-are-serverless-components-how-use/"},"frontmatter":{"title":"What are Serverless Components, and how do I use them?"}},"next":{"fields":{"slug":"/posts/2018-04-30-how-to-create-landing-page-with-serverless-components/"},"frontmatter":{"title":"How to create a landing page with serverless components"}}}}}