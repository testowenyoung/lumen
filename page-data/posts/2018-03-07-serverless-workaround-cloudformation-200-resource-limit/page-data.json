{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2018-03-07-serverless-workaround-cloudformation-200-resource-limit/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"aac34bb5-9a4f-548c-9173-27777c2d33ae","excerpt":"Developing with Serverless is microservice friendly, but sometimes you don’t want microservices. Perhaps you like the comfort of keeping all your application…","html":"<p>Developing with Serverless is microservice friendly, but sometimes you don’t want microservices. Perhaps you like the comfort of keeping all your application logic in one place.</p>\n<p>That’s great, until you hit the oh-so-common error:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">Error --------------------------------------------------\n\nThe CloudFormation template is invalid: Template <span class=\"token function\">format</span> error: Number of resources, <span class=\"token number\">201</span>, is greater than maximum allowed, <span class=\"token number\">200</span></code></pre></div>\n<p>That’s right—CloudFormation has a limit of 200 resources per stack.</p>\n<p>In this post, I’ll give you some background on the CloudFormation limit and why it’s so easy to hit. Then, I’ll follow up with a few tips on how to avoid hitting the limit, including:</p>\n<ul>\n<li><a href=\"#break-your-web-api-into-microservices\">Break your web API into microservices</a></li>\n<li><a href=\"#handle-routing-in-your-application-logic\">Handle routing in your application logic</a></li>\n<li><a href=\"#split-your-stacks-with-plugins\">Using plugins to split your service into multiple stacks or nested stacks</a></li>\n<li><a href=\"#bug-your-AWS-contacts\">Pestering your AWS rep to get the CloudFormation limit increased</a></li>\n</ul>\n<p>Let’s begin!</p>\n<h2>Background on the 200 resource limit</h2>\n<p>Before we get too far, let’s understand the background on this issue and why it’s so easy to hit.</p>\n<p>When you run <code class=\"language-text\">serverless deploy</code> on a Serverless service that’s using AWS as a provider, a few things are happening under the hood:</p>\n<ol>\n<li>The Serverless Framework packages your functions into zip files in the format expected by Lambda</li>\n<li>The zip files are uploaded to S3</li>\n<li>A CloudFormation stack is deployed that includes your Lambda function, <a href=\"https://serverless.com/blog/abcs-of-iam-permissions/\">IAM permissions</a>, Cloudwatch log configuration, event source mappings, and a whole bunch of other undifferentiated heavy lifting that you shouldn’t care about</li>\n</ol>\n<p>The problem arises when you hit the aforementioned limit of 200 resources in a single CloudFormation stack. Unlike other service limits, this is a hard limit that AWS will not raise in a support request.</p>\n<p>Now you may be saying “But I only have 35 functions in my service—how does this equal 200 resources?”</p>\n<p>A single function requires more than one CloudFormation resource. For every function you add, there are at least three resources:</p>\n<ol>\n<li>An <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html\"><code class=\"language-text\">AWS::Lambda::Function</code></a> resource, representing your actual function</li>\n<li>An <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-version.html\"><code class=\"language-text\">AWS::Lambda::Version</code></a> resource, representing a particular <em>version</em> of your function (this allows for fast &#x26; easy rollbacks)</li>\n<li>An <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-loggroup.html\"><code class=\"language-text\">AWS::Logs::LogGroup</code></a> resource, allowing your function to log to CloudWatch logs</li>\n</ol>\n<p>If you wire up an event source such as <code class=\"language-text\">http</code> for API Gateway, you’ll be adding a few more resources:</p>\n<ol>\n<li><a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html\"><code class=\"language-text\">AWS::Lambda::Permission</code></a>, allowing API Gateway to invoke your function;</li>\n<li><a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-resource.html\"><code class=\"language-text\">AWS::ApiGateway::Resource</code></a>, configuring the resource path for your endpoint; and</li>\n<li><a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-method.html\"><code class=\"language-text\">AWS:ApiGateway::Method</code></a>, configuring the HTTP method for your endpoint.</li>\n</ol>\n<p>For each <code class=\"language-text\">http</code> event you configured, you end up creating <strong>six</strong> (!) CloudFormation resources, in addition to shared resources like <code class=\"language-text\">AWS::ApiGateway::RestApi</code> and <code class=\"language-text\">AWS::IAM::Role</code>.</p>\n<p>Given this, you’ll start to run into that limit around 30-35 HTTP functions. If this sounds like you, keep reading to see how you can avoid this problem.</p>\n<h2>Break your Web API into microservices</h2>\n<p>The most common place we see people run into the 200 resource limit is with web APIs. This can be perfectly RESTful APIs, RPC-like endpoints, or something in between. Users often want to put a bunch of HTTP endpoints on the same domain.</p>\n<p>By default, the Serverless Framework creates a new API Gateway domain for each service. However, there are two ways you can manage to put endpoints from different services in the same domain.</p>\n<p>The first way, and my preferred way, is to map your API Gateway domains to a custom domain that you own. When you create an API Gateway in AWS, it will give you a nonsense domain such as <code class=\"language-text\">https://n0benf6jn4.execute-api.us-east-1.amazonaws.com</code>. However, you can <a href=\"https://serverless.com/blog/serverless-api-gateway-domain/\">map over this domain using a custom domain that you own</a>, such as <code class=\"language-text\">https://api.mycompany.com</code>. This is much cleaner, plus it won’t change if you remove and redeploy your service — much more reliable for clients that you can’t change.</p>\n<p>Further, if you use a custom domain, you can also utilize <em>base path mappings</em> to segment your services and deploy multiple to the same domain. For example, if you have 30 routes, 15 of which are user-related and 15 of which are product-related, you can split them into two different services. The first, with all of your user-related routes, will have a base path mapping of “users”, which will prefix all routes with <code class=\"language-text\">/users</code>. The second, with your product-related routes, will prefix your routes with <code class=\"language-text\">/products</code>.</p>\n<p><strong>Aside:</strong> Interested in using a custom domain with base path mapping? Check out our two posts on the subject: <a href=\"https://serverless.com/blog/serverless-api-gateway-domain/\">How to set up a custom domain with Serverless</a> and <a href=\"https://serverless.com/blog/api-gateway-multiple-services/\">How to deploy multiple micro-services under one domain</a>.</p>\n<p>A second approach is to use the <code class=\"language-text\">apiGateway</code> property object in your <code class=\"language-text\">serverless.yml</code>. This was added in the <code class=\"language-text\">v1.26</code> release of the Serverless Framework. It allows you to re-use an existing API Gateway REST API resource. You’ll have the nonsense domain (<code class=\"language-text\">https://n0benf6jn4.execute-api.us-east-1.amazonaws.com</code>), but it won’t require you to shell out the $12 for a custom domain of your own.</p>\n<p>Check out the docs on the new <code class=\"language-text\">apiGateway</code> property <a href=\"https://serverless.com/framework/docs/providers/aws/events/apigateway#share-api-gateway-and-api-resources\">here</a>.</p>\n<h2>Handle routing in your application logic</h2>\n<p>Warning: The following advice is considered heresy in certain serverless circles. Use at your own risk.</p>\n<p>If you don’t want to split up your logic into multiple services, you can try an alternative route—stuffing all of your logic into a single function!</p>\n<p>Here’s how it works. Rather than setting up specific HTTP endpoints that map to specific function handlers, you set up a single route that catches <em>all</em> HTTP paths. In your <code class=\"language-text\">serverless.yml</code>, it will look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">functions</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">handler</span><span class=\"token punctuation\">:</span> myHandler.main\n    <span class=\"token key atrule\">events</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">http</span><span class=\"token punctuation\">:</span> ANY /\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">http</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'ANY {proxy+}'</span></code></pre></div>\n<p>The first event matches any method request on <code class=\"language-text\">/</code>, and the second event matches any method request on any other path. All requests will get sent to <code class=\"language-text\">myHandler.main</code>. From there, your logic should inspect the HTTP method and path to see what handler it needs to invoke, then forward the request to that handler within your function.</p>\n<p>Conceptually, this is very similar to how it works with the web frameworks of old, such as Express for Nodejs and Flask for Python. API Gateway is similar to Nginx or Apache — a reverse proxy that forwards HTTP events to your application. Then Express or Flask would take those events from Nginx or Apache, figure out the relevant route, and send it to the proper function.</p>\n<p>It’s very easy to use these existing web frameworks with Serverless. You can check our prior posts for <a href=\"https://serverless.com/blog/serverless-express-rest-api/\">using Express with Serverless</a> or <a href=\"https://serverless.com/blog/flask-python-rest-api-serverless-lambda-dynamodb/\">deploying a Flask REST API with Serverless</a>.</p>\n<p>Even if you don’t want to use existing web frameworks, you can build your own routing layer inside your Lambda. Our good friends at Trek10 built a <a href=\"https://github.com/trek10inc/lambda-router\"><code class=\"language-text\">lambda-router</code></a> package that you can look at, and there are a number of other options available as well.</p>\n<p>If you’re thinking of taking this route, I strongly suggest reading Yan Cui’s (aka <a href=\"https://twitter.com/theburningmonk\">theburningmonk</a>) post on <a href=\"https://hackernoon.com/aws-lambda-should-you-have-few-monolithic-functions-or-many-single-purposed-functions-8c3872d4338f\">monolithic vs multi-purpose functions</a>. As always, Yan has great insight on some deep serverless topics.</p>\n<h2>Split your stacks with plugins</h2>\n<p>If you’ve gotten this far, you’re a hold out. You don’t want to split your services. You don’t want a mono-function. But\nyou still have over 200 resources.</p>\n<p>It’s time to explore using multiple CloudFormation stacks.</p>\n<p>There are a few ways we can do this. First, you can simply move certain parts of your application into a different CloudFormation stack, even if it’s managed in the same service. Examples of this would be to put your slow-changing infrastructure, such as VPCs, Subnets, Security Groups, Databases, etc. in one stack, then have your more dynamic infrastructure like Lambda functions, event subscriptions, etc. in a different CloudFormation stack. For most deploys, you’ll only be deploying the dynamic stack. Occasionally, you’ll want to deploy the slow-changing stack.</p>\n<p>If this sounds good to you, check out the <a href=\"https://github.com/SC5/serverless-plugin-additional-stacks\"><code class=\"language-text\">serverless-plugin-additional-stacks</code></a> plugin by the folks at SC5.</p>\n<p>The second approach is to use <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html\">Nested Stacks</a> with CloudFormation. You can use Nested Stacks to create a hierarchy of stacks. The Stacks are linked together, but each one gets to use the full 200 resource limit.</p>\n<p>Warning: Nested Stacks are a pretty advanced area of CloudFormation, and they’re not for the faint of heart. Make sure you know what you’re doing.</p>\n<p>If Nested Stacks sound like the solution for you, check out these two plugins:</p>\n<ul>\n<li><a href=\"https://github.com/jagdish-176/serverless-nested-stack\"><code class=\"language-text\">serverless-nested-stack</code></a>, which splits your LogGroups and Roles into one Stack, and all other resources into another, and</li>\n<li><a href=\"https://github.com/dougmoscrop/serverless-plugin-split-stacks\"><code class=\"language-text\">serverless-plugin-split-stacks</code></a>, by the great Doug Moscrop, creator of the <code class=\"language-text\">serverless-http</code> plugin and many others.</li>\n</ul>\n<h2>Bug your AWS contacts</h2>\n<p>You know what to do. Send out a tweet with <code class=\"language-text\">#awswishlist</code> or ping your AWS support rep and let them know you’d like the 200 resource limit raised.</p>\n<h2>Conclusion</h2>\n<p>The 200 resource limit in CloudFormation can be an annoyance, but luckily there are a few workarounds. Let us know if you have other methods for getting around this limit.</p>","frontmatter":{"title":"Serverless Workarounds for CloudFormation's 200 Resource Limit","date":"March 07, 2018","description":"How you can troubleshoot, and avoid hitting, CloudFormation's 200 resource limit"}}},"pageContext":{"slug":"/posts/2018-03-07-serverless-workaround-cloudformation-200-resource-limit/","previous":{"fields":{"slug":"/posts/2018-02-26-best-tools-serverless-observability/"},"frontmatter":{"title":"Best tools for serverless observability"}},"next":{"fields":{"slug":"/posts/2018-03-09-serverless-by-the-numbers-2018-data-report/"},"frontmatter":{"title":"Serverless by the numbers: 2018 report"}}}}}