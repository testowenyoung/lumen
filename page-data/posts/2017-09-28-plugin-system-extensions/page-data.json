{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2017-09-28-plugin-system-extensions/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"50c65c8f-1c11-5e88-a305-86323b10e47d","excerpt":"Introduction It’s been quite a while since my last post about plugins, way back in the ancient days of Serverless 1.12. The Framework is in its 20’s now and so…","html":"<h2>Introduction</h2>\n<p>It’s been quite a while since my <a href=\"https://serverless.com/blog/advanced-plugin-development-extending-the-core-lifecycle/\">last post about plugins</a>, way back in the ancient days of Serverless 1.12. The <a href=\"https://serverless.com/framework/\">Framework</a> is in its 20’s now and so grown up…(sniffle).</p>\n<p>Things have changed since then. It’s a new age, filled with new features. Your dreams of being a plugin author have never been easier to achieve.</p>\n<p>Let’s do this.</p>\n<h3>Table of contents</h3>\n<ul>\n<li><a href=\"https://serverless.com/blog/plugin-system-extensions/#command-aliases\">Command aliases</a></li>\n<li><a href=\"https://serverless.com/blog/plugin-system-extensions/#command-delegates-lifecycle-termination\">Command delegates</a></li>\n<li><a href=\"https://serverless.com/blog/plugin-system-extensions/#enhanced-logging\">Enhanced logging</a></li>\n</ul>\n<h2>Command aliases</h2>\n<h3>Before</h3>\n<p>Every plugin installs a unique set of commands. Since the command lifecycle and the hookable lifecycle are rooted at the command names, the commands cannot be changed.</p>\n<p>E.g. the deploy function lifecycle is built from these events: <code class=\"language-text\">deploy:function:initialize</code>, <code class=\"language-text\">deploy:function:packageFunction</code> and <code class=\"language-text\">deploy:function:deploy</code>.</p>\n<p>From a UX perspective, wouldn’t it would be more natural to access the function deployment as subcommand of a <code class=\"language-text\">function</code> command (i.e. <code class=\"language-text\">serverless function deploy</code>)?</p>\n<p>But alas, if you rename the command to <code class=\"language-text\">function:deploy</code> it also changes the command hooks, and any plugins depending on these hooks cease to function. Whoops!</p>\n<h3>Now</h3>\n<p>The solution? <strong>Command aliases</strong>.</p>\n<p>Commands can now have specified alternatives (aliases), and you can use those alises to access the command from the CLI.</p>\n<p>Invoking a command alias is internally no different than invoking the original command—it will start the original command’s lifecycle and run through all known lifecycle events. So, any hooked plugin will work exactly the same as with the original command.</p>\n<p>Aliases are simply added to any command definition. You can even specify multiple aliases! However, aliases cannot overwrite existing commands and Serverless will error accordingly if you try to do so.</p>\n<p>Here is an example of the aforementioned <code class=\"language-text\">deploy function</code> command (code from <code class=\"language-text\">./lib/plugins/deploy/deploy.js</code>):</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>commands <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  deploy<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>\n    commands<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">function</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        usage<span class=\"token operator\">:</span> <span class=\"token string\">'Deploy a single function from the service'</span><span class=\"token punctuation\">,</span>\n        lifecycleEvents<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n        aliases<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n          <span class=\"token string\">'function:deploy'</span>\n        <span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This sample makes the <code class=\"language-text\">deploy function</code> command available as <code class=\"language-text\">function deploy</code>. As you can see, aliases implicitly create hierarchies when needed (here: a virtual <code class=\"language-text\">function</code> command level).</p>\n<p>In general, the alias command position is not limited and can also be a <em>new</em> subcommand of any existing command.</p>\n<p><code class=\"language-text\">serverless help</code> will also reflect existing aliases, in addition to printing both the aliased command and the original command description.</p>\n<h2>Command delegates (lifecycle termination)</h2>\n<h3>Before</h3>\n<p>Sometimes, depending on the options given, you’ll need to delegate execution to a different command. E.g., our example from above, where <code class=\"language-text\">serverless deploy --function=XXXX</code> now executes the <code class=\"language-text\">deploy function</code> command instead of <code class=\"language-text\">deploy</code>.</p>\n<p>But how is this done?</p>\n<p>As you might remember, there is <code class=\"language-text\">pluginManager.spawn()</code> that starts a command from within a lifecycle event. It returns\nafter execution so that the current lifecycle (command) is continued afterwards.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CLI\n  + cmd1\n    + lifecycleEvent1cmd1\n      --&gt; spawn(cmd2)\n            + lifecycleEvent1cmd2\n            + lifecycleEvent2cmd2\n      &lt;--\n    + lifecycleEvent2cmd1\n    + lifecycleEvent3cmd1</code></pre></div>\n<p>This mechanism works great, but only if you want to run another lifecycle <em>within</em> your lifecycle.</p>\n<p>In our case, we want to delegate the execution to the other command, but we do <em>not</em> want to continue our own lifecycle. This means we do not want to run the <code class=\"language-text\">deploy</code> lifecycle, because we want to run <code class=\"language-text\">deploy function</code> if we encounter a <code class=\"language-text\">--function</code> option on the commandline.</p>\n<p>So what we actually want is:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CLI\n  + cmd1\n    + lifecycleEvent1cmd1\n      --&gt; spawn(cmd2)\n            + lifecycleEvent1cmd2\n            + lifecycleEvent2cmd2\n      &lt;--\n      ABORT THE CMD1 LIFECYCLE\n    &lt;--</code></pre></div>\n<p>This behavior effectively replaces the execution of cmd1 with cmd2 after the initial lifecycle event of cmd1 has been started.</p>\n<h3>Now</h3>\n<p>Thanks to the latest extension of <code class=\"language-text\">pluginManager.spawn()</code>, this is now possible. The spawn method now accepts a second <em>option</em> parameter that lets you switch special behavior of the spawn on or off (<code class=\"language-text\">pluginManager.spawn(command, options)</code>).</p>\n<p>The option that we use is the new <code class=\"language-text\">terminateLifecycleAfterExecution</code> option. Setting it to <code class=\"language-text\">true</code> will spawn the command\nand its lifecycle as before, but as soon as the invoked lifecycle terminates, it will also terminate our current lifecycle and\nreturn control to our invoker (i.e., someone who spwaned us or the CLI).</p>\n<p>Example (<code class=\"language-text\">deploy --function</code> delegate invocation, see <code class=\"language-text\">./lib/plugins/deploy/deploy.js</code>):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    this.hooks = {\n      &#39;before:deploy:deploy&#39;: () =&gt; BbPromise.bind(this)\n        .then(this.validate)\n        .then(() =&gt; {\n          if (this.options.function) {\n            // If the user has given a function parameter, spawn a function deploy\n            // and terminate execution right afterwards. We did not enter the\n            // deploy lifecycle yet, so nothing has to be cleaned up.\n            return this.serverless.pluginManager.spawn(\n              &#39;deploy:function&#39;, { terminateLifecycleAfterExecution: true }\n            );\n          }</code></pre></div>\n<p>It is important to remember that a terminating spawn will not execute any subsequent lifecycles of the current command. I recommend that you do not spawn with termination when you depend on any subsequent event in the current lifecycle to do some cleanups. The deploy command delegates right after the validation step.</p>\n<h2>Enhanced logging</h2>\n<p>A much-requested feature was improved logging, especially for plugin authors. There have been some changes that allow us to\nlet us debug our plugins with fewer headaches.</p>\n<h3>Stacktraces on plugin crashes</h3>\n<p>When the <code class=\"language-text\">SLS_DEBUG</code> environment variable is set, Serverless now prints the stacktraces of the crash (even if it happened\nwithin a plugin), instead of just telling us that the plugin could not be loaded.</p>\n<h3>Plugin loading and command registration</h3>\n<p>With <code class=\"language-text\">SLS_DEBUG</code> the plugin manager will now output any commands as well as aliases that are registered during the plugin loading.</p>\n<p>This allows us to debug crashes during plugin initialization, and shows us the exact location where commands and aliases have clashes.</p>\n<h3>Log of spawned and invoked commands</h3>\n<p>With <code class=\"language-text\">SLS_DEBUG</code>, all commands that are started via invoke or spawn are now logged. This allows you to see if you spawn commands correctly or if there are any plugins that change the event chain in an unexpected way.</p>\n<h2>Grand finale</h2>\n<p>That’s it, team. Now you have no excuses—go author the next big plug-in!</p>","frontmatter":{"title":"What's new for Serverless plugins?","date":"September 29, 2017","description":"Being a Serverless plugin author has never been easier. Take advantage of these awesome new features to write your very own plugin."}}},"pageContext":{"slug":"/posts/2017-09-28-plugin-system-extensions/","previous":{"fields":{"slug":"/posts/2017-09-26-serverless-monitoring-the-good-the-bad-and-the-ugly/"},"frontmatter":{"title":"Serverless monitoring - the good, the bad and the ugly"}},"next":{"fields":{"slug":"/posts/2017-10-03-things-i-learned-designing-developer-tools/"},"frontmatter":{"title":"3 things I learned designing developer-centric tools at Serverless"}}}}}