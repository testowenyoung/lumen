{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2018-08-09-django-serverless-framework-a-match-made-in-heaven/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"115877ca-795d-50d5-b6d9-9ca08e8b97ee","excerpt":"I started using Django seriously 2 years ago, and I think it‚Äôs an exceptional framework. In addition to its core strength, Django has a vast list of add-ons and‚Ä¶","html":"<p>I started using Django seriously 2 years ago, and I think it‚Äôs an exceptional framework.</p>\n<p>In addition to its core strength, Django has a vast list of add-ons and supporting libraries. One of those gems is called the Django Rest Framework (or DRF for short), a library that gives developers an easy-to-use, out-of-the-box REST functionality that plugs seamlessly with Django‚Äôs ORM functionality.</p>\n<p>But what if you want to do this serverless-ly? In this post, I‚Äôll talk about deploying serverless Django apps with the Serverless Framework!</p>\n<h2>Django: the SQL beast</h2>\n<p>Django is powerful, but it‚Äôs also heavily dependent on a SQL database like MySql or Postgresql. No matter how hard I tried, I couldn‚Äôt find any Django DB engine that is able to work on top of AWS DynamoDB.</p>\n<p>The solution I‚Äôm suggesting here is built from 2 components:</p>\n<ol>\n<li>Using RDS. RDS is a managed SQL service, but not completely serverless; you pay for idle, and it does not scale automatically.</li>\n<li>Using a VPC. When using RDS, this is a necessary step for security. When adding VPC into the mix, your Lambda must also run inside the VPC, which leads to slow starts and <a href=\"https://gist.github.com/efi-mk/d6586669a472be8ea16b6cf8e9c6ba7f\">a complicated configuration</a>.</li>\n</ol>\n<p>But, all that is too complicated for my demo. I wanted something quick and dirty.</p>\n<h3>Using SQLite</h3>\n<p>SQLite here I come!</p>\n<p>Ok, so <a href=\"https://www.sqlite.org/index.html\">SQLite</a> is actually not that dirty. It‚Äôs the right tool for constrained environments (like mobile), or when you don‚Äôt need to save a lot of data and you want to keep everything in memory.</p>\n<p>Global shared configuration might be a good idea. Have a look at the following diagram:</p>\n<p><img src=\"https://user-images.githubusercontent.com/822542/43189524-7331b9c8-8fff-11e8-8dc7-75612d36ff65.png\" alt=\"sqlite\"></p>\n<ul>\n<li>You have a lambda function that requires configuration in order to function, the configuration is saved in a SQLite DB located in S3 bucket.</li>\n<li>The Lambda pulls the SQLite on startup and does its magic.</li>\n<li>On the other end, you have a management console that does something similar, it pulls the SQLite DB, changes it and puts it back</li>\n<li>Pay attention that only <strong>a single writer is allowed here</strong>, otherwise things will get out of sync.</li>\n</ul>\n<p>How long will it take us to develop this? None. <a href=\"https://blog.zappa.io/posts/s3sqlite-a-serverless-relational-database\">We can use this one</a> from Zappa. Let‚Äôs call it Serverless SQLite, or ‚ÄòSSQL‚Äô for short.</p>\n<h2>Let‚Äôs get this thing started</h2>\n<p>Let‚Äôs define what we‚Äôre building here:</p>\n<ul>\n<li>It‚Äôs going to be a Django app with the appropriate Django admin for our models</li>\n<li>You should be able to log into the admin and add or change configuration.</li>\n<li>The user should be able to call a REST API created by DRF to read configuration details, something very similar to to <a href=\"https://serverless.com/blog/flask-python-rest-api-serverless-lambda-dynamodb/\">this Python rest API</a>.</li>\n</ul>\n<p>You can find all the code for the demo <a href=\"https://github.com/efi-mk/serverless-django-demo\">here</a>.</p>\n<p>I‚Äôm assuming you already know how to create a <a href=\"https://docs.djangoproject.com/en/2.0/intro/tutorial01/\">Django app</a>, so we‚Äôll skip the boring stuff and concentrate on the extra steps required to set up this app.</p>\n<h3>WSGI configuration</h3>\n<p>It‚Äôs something small, but that‚Äôs what‚Äôs doing the magic. In <code class=\"language-text\">serverless.yml</code>, the wsgi configuration points to the <code class=\"language-text\">wsgi</code> app that Django exposes.</p>\n<h3>SSQL configuration</h3>\n<p>Under <code class=\"language-text\">settings.py</code> a configuration was added which loads the SSQL DB driver:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">    DATABASES <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token string\">'default'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token string\">'ENGINE'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'zappa_django_utils.db.backends.s3sqlite'</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">'NAME'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'sqlite.db'</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">'BUCKET'</span><span class=\"token punctuation\">:</span> SQLITE_BUCKET\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p>But when testing locally, I do not want to connect to any S3 bucket. It slows down the operation. Therefore, we‚Äôll make a check to verify whether we are running a Lambda environment or not. If not, then we‚Äôll load the regular SQLite driver:</p>\n<p><code class=\"language-text\">IS_OFFLINE = os.environ.get(‚ÄòLAMBDA_TASK_ROOT‚Äô) is None</code></p>\n<p>I prefer not to run <code class=\"language-text\">sls wsgi serve</code>, because Django already has wonderful management CLI support. Instead, I like to run <code class=\"language-text\">manage.py runserver</code>.</p>\n<p>As part of its configuration, SSQL requires a bucket name. You can create it manually and set the name in <code class=\"language-text\">local_settings.py</code>, but note that under <code class=\"language-text\">serverless.yml</code> the Lambda function has <code class=\"language-text\">Get</code> and <code class=\"language-text\">Put</code> permissions on all S3 buckets. You should use your S3 bucket ARN instead.</p>\n<h3>WhiteNoise configuration</h3>\n<p><a href=\"http://whitenoise.evans.io/en/stable/\">WhiteNoise</a> allows our web app to serve its own static files, without relying on nginx, Amazon S3 or any other external service.</p>\n<p>We‚Äôll use this library to serve our static admin files. I‚Äôm not going to go over all the configuration details here, but <a href=\"https://github.com/evansd/whitenoise/issues/164\">you can feel free follow them on your own</a>. Make sure the static files are part of the Lambda package.</p>\n<h3>A tale of a missing SO</h3>\n<p>While trying to make it work, I encountered a strange error‚Äî<em>Unable to import module ‚Äòapp‚Äô: No module named ‚Äò_sqlite3‚Äô.</em> After some digging, I found out that the Lambda environment does not contain the shared library which is required by SQLite. üò≤</p>\n<p>Luckily, Zappa has provided a compiled SO which is packaged as part of the deployment script.</p>\n<h3>Deployment script</h3>\n<p>Let‚Äôs review the step:</p>\n<ul>\n<li>Collect all static files ‚úîÔ∏è</li>\n<li>Migrate our remote DB before code deployment ‚úîÔ∏è</li>\n<li>Create a default admin <code class=\"language-text\">root</code> user with password <code class=\"language-text\">MyPassword</code> ‚úîÔ∏è</li>\n<li>Add _sqlite3.so to the mix ‚úîÔ∏è</li>\n<li><code class=\"language-text\">sls deploy</code> ‚úîÔ∏è</li>\n</ul>\n<p>You have a deploy script located under <code class=\"language-text\">scripts</code> folder.</p>\n<h3>So how do I prepare my environment locally?</h3>\n<ol>\n<li><code class=\"language-text\">npm install ‚Äî save-dev serverless-wsgi serverless-python-requirements</code></li>\n<li>Create a virtual env for your python project</li>\n<li><code class=\"language-text\">pip install -r requirements.txt</code></li>\n<li>Run DB migration: <code class=\"language-text\">./manage.py migrate</code></li>\n<li>Create a super user for the management console: <code class=\"language-text\">./manage.py createsuperuser</code></li>\n<li>Run the server locally: <code class=\"language-text\">./manage.py runserver</code></li>\n<li>Go to <a href=\"http://127.0.0.1:8000/admin\">http://127.0.0.1:8000/admin</a> and log in onto the management console; add a configuration</li>\n<li>Try <code class=\"language-text\">curl -H ‚ÄúContent-Type: application/json‚Äù -X GET [http://127.0.0.1:8000/configuration/](http://127.0.0.1:8000/configuration/)</code> and see if you get the configuration back</li>\n</ol>\n<h2>Fin</h2>\n<p>We covered how to use Django with the Serverless Framework, using SQLite as our SQL database, which was served from a S3 bucket.</p>\n<p>I hope you enjoyed the journey! You are more than welcom to ask question below, and/or <a href=\"https://github.com/efi-mk/serverless-django-demo\">fork the repository</a>.</p>","frontmatter":{"title":"Deploy a REST API using Serverless, Django and Python","date":"August 09, 2018","description":"Use the Serverless Framework, Django, SQLite and Python to quickly deploy a REST API."}}},"pageContext":{"slug":"/posts/2018-08-09-django-serverless-framework-a-match-made-in-heaven/","previous":{"fields":{"slug":"/posts/2018-08-07-how-use-event-gateway-use-cases-rest-api-custom-events/"},"frontmatter":{"title":"How to use the Serverless Event Gateway: build a REST API and react to custom events"}},"next":{"fields":{"slug":"/posts/2018-08-15-streamline-serverless-workflow-webstorm/"},"frontmatter":{"title":"How to streamline your serverless workflow with WebStorm"}}}}}