{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2019-05-14-s3-one-time-signed-url/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"65896bd4-d4dd-5db7-b92c-f320bf1e6e86","excerpt":"AWS provides the means to upload files to an S3 bucket using a pre signed URL. The URL is generated using IAM credentials or a role which has permissions to…","html":"<p>AWS provides the means to upload files to an S3 bucket using a pre signed URL. The URL is generated using IAM credentials or a role which has permissions to write to the bucket. A pre signed URL has an expiration time which defines the time when the upload has to be started, after which access is denied. The problem is that the URL can be used multiple times until it expires, and if a malevolent hacker gets their hands on the URL, your bucket may contain some unwanted data.</p>\n<p>How then do we prevent the usage of the presigned URL after the initial upload?</p>\n<p>The following example will leverage CloudFront and Lambda@Edge functions to expire the presigned URL when the initial upload starts, preventing the use of the URL </p>\n<p>Lambda@Edge functions are similar to AWS Lambda functions, but with a few limitations. The allowed execution time and memory size are smaller than in regular Lambda functions, and no environmental variables can be used.</p>\n<p><a href=\"https://github.com/laardee/one-time-presigned-url\">The example project</a> is made with the Serverless Framework. Let’s go through the basic concept and components.</p>\n<h2>The Concept</h2>\n<p>The objective is to ensure that every pre signed URL is only ever used once, and becomes unavailable after the first use.</p>\n<p>I had a few different ideas for the implementation until I settled on one that seemed to be the most efficient at achieving our objective.</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/s3-one-time-signed-url/Serverless_Graph01-s3-signed-url-at-edge-get-signed-url.png\" alt=\"s3-signed-url-at-edge-get-signed-url\">\n<strong>Figure 1.</strong> Presigned URL creation</p>\n<p>First, the user makes a request to the /url endpoint (step 1, Figure 1). This in turn triggers a lambda function (step 2, Figure 1) which creates a presigned URL using the S3 API (step 3, Figure 1). A hash is then created from the URL and saved to the bucket (step 4, Figure 1) as a valid signature. The Lambda function creates a response which contains the URL (step 5, Figure 1) and returns it to the user (step 6, Figure 1).</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/s3-one-time-signed-url/Serverless_Graph02-s3-signed-url-at-edge-validate.png\" alt=\"s3-signed-url-at-edge-validate\">\n<strong>Figure 2.</strong> Verification of the presigned URL</p>\n<p>The user then uses that URL to upload the file (step 1, Figure 2). A Cloudfront viewer request triggers a Lambda function(step 2, Figure 2) which verifies that the hashed URL is indexed as a valid token and is not indexed as an expired token (step 3, Figure 2). If we have a match from both conditions, the current hash is written to the expired signatures index (step 4, Figure 2).</p>\n<p>In addition to that, the version of the expired signature object is checked. If this is the first version of this particular expired hash everything is ok (step 5, Figure 2). This check is meant to prevent someone intercepting the original response with a signed URL and using it before the legitimate client has had a chance to.</p>\n<p>After all the verifications have successfully passed, the original request is returned to Cloudfront (step 6, Figure 2) and to the bucket (step 7, Figure 2), which then decides if the presigned URL is valid for PUTting the object.</p>\n<h2>AWS Resources</h2>\n<p>The S3 bucket will contain the uploaded files and an index of used signatures. There no need for bucket policy, ACLs, or anything else; the bucket is private and cannot be accessed from outside without a pre signed URL.</p>\n<p>The generation and invalidation of the signed URLs will happen on the Lambda@Edge functions, which are triggered in the CloudFront’s viewer request stage. Functions have a role which allows them to generate the presigned URL, check if the URL hash is in the valid index and add it if not.</p>\n<p>The bucket and CloudFront distribution are defined in the resources block of the <code class=\"language-text\">serverless.yml</code> file. Since we cannot pass configuration values via environment variables (since Lambda@Edge functions cannot access environment variables), the bucket name is stored and fetched from an external json file.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">Bucket</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">Type</span><span class=\"token punctuation\">:</span> AWS<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>S3<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>Bucket\n  <span class=\"token key atrule\">Properties</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">BucketName</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>custom.config.bucket<span class=\"token punctuation\">}</span>\n    <span class=\"token key atrule\">BucketEncryption</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">ServerSideEncryptionConfiguration</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">ServerSideEncryptionByDefault</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">SSEAlgorithm</span><span class=\"token punctuation\">:</span> AES256\n    <span class=\"token key atrule\">VersioningConfiguration</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">Status</span><span class=\"token punctuation\">:</span> Enabled\n    <span class=\"token key atrule\">CorsConfiguration</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">CorsRules</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">AllowedHeaders</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'*'</span><span class=\"token punctuation\">]</span>\n          <span class=\"token key atrule\">AllowedMethods</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>GET<span class=\"token punctuation\">,</span> PUT<span class=\"token punctuation\">]</span>\n          <span class=\"token key atrule\">AllowedOrigins</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'*'</span><span class=\"token punctuation\">]</span>\n          <span class=\"token key atrule\">Id</span><span class=\"token punctuation\">:</span> CORSRuleId1\n          <span class=\"token key atrule\">MaxAge</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'3600'</span></code></pre></div>\n<p>The Cloudfront distribution has its origin set to our S3 bucket, and it has two behaviours; the default is to perform the upload with a pre signed URL, the second supports a URL pattern of /url which will respond with the presigned URL that is used for the upload.</p>\n<p>The default behaviour in the distribution configuration allows all the HTTP methods so that <code class=\"language-text\">PUT</code> can be used to upload files. S3 allows files up to 5 gigabytes to be uploaded with that method, although it is better to use multipart upload for files bigger than 100 megabytes. For simplicity, this example uses only <code class=\"language-text\">PUT</code>.</p>\n<p>Cloudfront should also forward the query string which contains the signature and token for the upload.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">ForwardedValues</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">QueryString</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'true'</span> <span class=\"token comment\"># S3 presigned URL</span>\n  <span class=\"token key atrule\">Cookies</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">Forward</span><span class=\"token punctuation\">:</span> none\n<span class=\"token key atrule\">AllowedMethods</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> DELETE\n  <span class=\"token punctuation\">-</span> GET\n  <span class=\"token punctuation\">-</span> HEAD\n  <span class=\"token punctuation\">-</span> OPTIONS\n  <span class=\"token punctuation\">-</span> PATCH\n  <span class=\"token punctuation\">-</span> POST\n  <span class=\"token punctuation\">-</span> PUT <span class=\"token comment\"># Method used for upload</span></code></pre></div>\n<p>The behaviour for the <code class=\"language-text\">/url</code> pattern only allows GET and HEAD methods and it doesn’t have to forward anything; the response will be created by the Lambda function.</p>\n<p>The origin contains only the domain name, which is the bucket name, and id. The <code class=\"language-text\">S3OriginConfig</code> is an empty object because the bucket will be private. If you want to allow users to view files which are saved to the bucket, the origin access identity can be set.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">Origins</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">DomainName</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span>self<span class=\"token punctuation\">:</span>custom.config.bucket<span class=\"token punctuation\">}</span>.s3.amazonaws.com\n    <span class=\"token key atrule\">Id</span><span class=\"token punctuation\">:</span> S3Origin\n    <span class=\"token key atrule\">S3OriginConfig</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Lambda Functions</h3>\n<p>Both of the functions are triggered in the viewer request stage, which is when CloudFront receives the request from the end user (browser, mobile app, and such).</p>\n<p>The function which creates the presigned URL is straightforward; it uses the AWS SDK to create the URL, stores a hash of the URL to the bucket and returns the URL. I’m using node UUID module to generate a random object key for each upload.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> signedUrl <span class=\"token operator\">=</span> s3<span class=\"token punctuation\">.</span><span class=\"token function\">getSignedUrl</span><span class=\"token punctuation\">(</span><span class=\"token string\">'putObject'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  Bucket<span class=\"token operator\">:</span> bucket<span class=\"token punctuation\">,</span>\n  Key<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">uploads/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token function\">uuidv4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This will return the full URL to the S3 bucket with presigned URL as a query string. As Cloudfront is used in front of the bucket, the URL domain must be the domain of the Cloudfront distribution. The path part is parsed from the signed URL using node URL module and CloudFront distribution domain is available in the request headers.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> path <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> url<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>signedUrl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> host <span class=\"token operator\">=</span> headers<span class=\"token punctuation\">.</span>host<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  status<span class=\"token operator\">:</span> <span class=\"token string\">'200'</span><span class=\"token punctuation\">,</span>\n  statusDescription<span class=\"token operator\">:</span> <span class=\"token string\">'OK'</span><span class=\"token punctuation\">,</span>\n  headers<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">'content-type'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token punctuation\">{</span>\n        key<span class=\"token operator\">:</span> <span class=\"token string\">'Content-Type'</span><span class=\"token punctuation\">,</span>\n        value<span class=\"token operator\">:</span> <span class=\"token string\">'text/plain'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'content-encoding'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token punctuation\">{</span>\n        key<span class=\"token operator\">:</span> <span class=\"token string\">'Content-Encoding'</span><span class=\"token punctuation\">,</span>\n        value<span class=\"token operator\">:</span> <span class=\"token string\">'UTF-8'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  body<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">https://</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>host<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>path<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The function that checks whether the current upload is the first one uses the indices of signatures written into that same bucket. The first check is to confirm an entry in the “valid index” and that the “expired index” doesn’t contain the hash. Then the function will continue executing the code. Otherwise, it will return a <code class=\"language-text\">403 Forbidden</code> response.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>validSignature<span class=\"token punctuation\">,</span> expiredSignature<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n  <span class=\"token function\">headSignature</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'valid'</span><span class=\"token punctuation\">,</span> hash <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">headSignature</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'expired'</span><span class=\"token punctuation\">,</span> hash <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>validSignature <span class=\"token operator\">||</span> expiredSignature<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> forbiddenResponse<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If the entry doesn’t exist, then it will write current filename and signature to index.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> VersionId<span class=\"token operator\">:</span> version <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> s3<span class=\"token punctuation\">.</span><span class=\"token function\">putObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  Bucket<span class=\"token operator\">:</span> bucket<span class=\"token punctuation\">,</span>\n  Key<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">signatures/expired/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>hash<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n  Body<span class=\"token operator\">:</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> created<span class=\"token operator\">:</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  ContentType<span class=\"token operator\">:</span> <span class=\"token string\">'application/json'</span><span class=\"token punctuation\">,</span>\n  ContentEncoding<span class=\"token operator\">:</span> <span class=\"token string\">'gzip'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Lastly, there is an extra check that fetches the versions of the index key. If it is not the first version, the response is again <code class=\"language-text\">403 Forbidden</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> Versions<span class=\"token operator\">:</span> versions <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> s3<span class=\"token punctuation\">.</span><span class=\"token function\">listObjectVersions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  Bucket<span class=\"token operator\">:</span> bucket<span class=\"token punctuation\">,</span>\n  Prefix<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">signatures/expired/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>hash<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> sortedVersions <span class=\"token operator\">=</span> versions<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">.</span>LastModified <span class=\"token operator\">></span> b<span class=\"token punctuation\">.</span>LastModified<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sortedVersions<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> sortedVersions<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>VersionId <span class=\"token operator\">!==</span> version<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> forbiddenResponse<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If the version id matches the initial version id, Lambda will pass the request on as it is to the origin.</p>\n<h3>Permissions</h3>\n<p>The function that creates the presigned URL needs to have s3:putObject permissions. The function that checks if the current upload is the initial upload requires permissions for s3:getObject, s3:putObject, s3:listBucket, and s3:listBucketVersions.</p>\n<h2>Development and Deployment</h2>\n<p>Deploying the stack with the Serverless Framework is easy; <code class=\"language-text\">sls deploy</code> and then wait. And wait. Everything related to Cloudfront takes time. At least 10 minutes. And removal of the replicated functions can take up to 45 minutes. That is a good driver for test driven development. The example project uses jest with a mocked AWS SDK; that way local development is fast and if you make small logic errors, they are caught before deployment.</p>\n<p>Bear in mind that Lambda@Edge functions are always deployed to the North Virginia (us-east-1) region. From there they are replicated to edge locations and called from the CDN closest to the client.</p>\n<h2>Time for a Test Run!</h2>\n<p>First, determine the domain name of the created distribution, either by logging in to the AWS web console or with the AWS CLI. The following snippet lists all the deployed distributions and shows domain names and comments. The comment field is the same one that is defined as a comment in the Cloudfront resource in <code class=\"language-text\">serverless.yml</code>. In the example, it is the service name, e.g. <code class=\"language-text\">dev-presigned-upload</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">aws cloudfront list-distributions <span class=\"token punctuation\">\\</span>\n     --query DistributionList.Items<span class=\"token punctuation\">[</span>*<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>DomainName,Comment<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">\\</span>\n     --region us-east-1</code></pre></div>\n<p>Pick the domain name from the list and run <code class=\"language-text\">curl https://DOMAIN_NAME/url</code>. Copy the response and then run following snippet.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">curl</span> --request PUT <span class=\"token punctuation\">\\</span>\n     --url <span class=\"token string\">\"URL_FROM_RESPONSE\"</span> <span class=\"token punctuation\">\\</span>\n     --verbose <span class=\"token punctuation\">\\</span>\n     --data <span class=\"token string\">\"My data\"</span></code></pre></div>\n<p>You should get something like this as a response.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token operator\">&lt;</span> HTTP/2 <span class=\"token number\">200</span>\n<span class=\"token operator\">&lt;</span> content-length: <span class=\"token number\">0</span>\n<span class=\"token operator\">&lt;</span> x-amz-id-2: uFQvK<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>c<span class=\"token operator\">=</span>\n<span class=\"token operator\">&lt;</span> x-amz-request-id: <span class=\"token number\">94</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>C1\n<span class=\"token operator\">&lt;</span> date: Tue, 07 May <span class=\"token number\">2019</span> 08:11:58 GMT\n<span class=\"token operator\">&lt;</span> x-amz-version-id: YQ<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>iR\n<span class=\"token operator\">&lt;</span> x-amz-server-side-encryption: AES256\n<span class=\"token operator\">&lt;</span> etag: <span class=\"token string\">\"1d...18\"</span>\n<span class=\"token operator\">&lt;</span> server: AmazonS3\n<span class=\"token operator\">&lt;</span> x-cache: Miss from cloudfront\n<span class=\"token operator\">&lt;</span> via: <span class=\"token number\">1.1</span> 9f<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token number\">72</span>.cloudfront.net <span class=\"token punctuation\">(</span>CloudFront<span class=\"token punctuation\">)</span>\n<span class=\"token operator\">&lt;</span> x-amz-cf-id: tx<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>jw<span class=\"token operator\">==</span></code></pre></div>\n<p>Then rerun the same upload snippet, with the same presigned URL, and the response should be the following.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token operator\">&lt;</span> HTTP/2 <span class=\"token number\">403</span>\n<span class=\"token operator\">&lt;</span> content-type: text/plain\n<span class=\"token operator\">&lt;</span> content-length: <span class=\"token number\">9</span>\n<span class=\"token operator\">&lt;</span> server: CloudFront\n<span class=\"token operator\">&lt;</span> date: Tue, 07 May <span class=\"token number\">2019</span> 08:18:11 GMT\n<span class=\"token operator\">&lt;</span> content-encoding: UTF-8\n<span class=\"token operator\">&lt;</span> x-cache: LambdaGeneratedResponse from cloudfront\n<span class=\"token operator\">&lt;</span> via: <span class=\"token number\">1.1</span> a5<span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>f4.cloudfront.net <span class=\"token punctuation\">(</span>CloudFront<span class=\"token punctuation\">)</span>\n<span class=\"token operator\">&lt;</span> x-amz-cf-id: <span class=\"token number\">44</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>Rg<span class=\"token operator\">==</span></code></pre></div>\n<p>In the latter example, the Lambda function has determined that the pre signed URL has already been used and responded with <code class=\"language-text\">403 Forbidden</code>.</p>\n<hr>\n<p>Now you have a Cloudfront distribution that creates pre signed URLs for uploading files and verifies that those are not used more than one time.</p>\n<p>To secure the endpoint that creates the presigned URL’s, you can create a custom authorizer which validates each request, e.g. using an authorization header or you can use AWS WAF to limit access.</p>\n<p>If you have any improvements or corrections related to the code, please open an issue or PR to the repository.</p>\n<p><strong>Links to relevant resources</strong></p>\n<ul>\n<li><a href=\"https://github.com/laardee/one-time-presigned-url\">Example project</a></li>\n<li><a href=\"https://serverless.com\">Serverless Framework</a></li>\n<li><a href=\"https://docs.aws.amazon.com/lambda/latest/dg/lambda-edge.html\">AWS Lambda@Edge docs</a></li>\n<li><a href=\"https://docs.aws.amazon.com/AmazonS3/latest/dev/PresignedUrlUploadObject.html\">Amazon S3 Presigned URL docs</a></li>\n</ul>","frontmatter":{"title":"Uploading objects to S3 using one-time pre signed URLs","date":"May 14, 2019","description":"Learn how to use Lambda@Edge to verify that S3 presigned URLs are only used once."}}},"pageContext":{"slug":"/posts/2019-05-14-s3-one-time-signed-url/","previous":{"fields":{"slug":"/posts/2019-05-09-framework-release-v142/"},"frontmatter":{"title":"Serverless Framework v1.42.0 -  API Gateway Logs, Binary Media Type Responses, Request Body Validations & More"}},"next":{"fields":{"slug":"/posts/2019-05-20-deploy-hybrid-serverless-cluster-workflows/"},"frontmatter":{"title":"Using the Serverless framework to deploy hybrid serverless/cluster workflows"}}}}}