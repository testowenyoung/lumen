{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2018-07-23-efficient-apis-graphql-serverless/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"bdc68deb-3331-50fd-a1f4-e60f86a64488","excerpt":"GraphQL can be a tool for building enlightened APIs, but it can also be a source of mystery for developers accustomed to REST. In this post, I’ll talk about the…","html":"<p>GraphQL can be a tool for building enlightened APIs, but it can also be a source of mystery for developers accustomed to REST.</p>\n<p>In this post, I’ll talk about the motivations that might lead you to choose GraphQL, and how to serve a GraphQL API that will let you really take advantage of its benefits.</p>\n<p>Here’s what we’ll be covering:</p>\n<ul>\n<li><a href=\"#rest-api-design\">REST API design</a></li>\n<li><a href=\"#enter-graphql\">A GraphQL approach</a></li>\n<li><a href=\"#making-your-graphql-endpoint-serverless\">Making your GraphQL endpoint serverless</a></li>\n</ul>\n<h2>REST API design</h2>\n<p>First, let’s talk about some situations that arise in REST APIs; this directly segues into when and why you would want to use GraphQL.</p>\n<p>Let’s say you have a REST resource to represent the products that your business offers:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GET /products/123\n{\n  &quot;id&quot;: &quot;123&quot;,\n  &quot;name&quot;: &quot;Widget&quot;,\n  &quot;price&quot;: &quot;$10.00&quot;\n}</code></pre></div>\n<p>And also a resource for orders by customers:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GET /orders/445566\n{\n  &quot;id&quot;: &quot;445566&quot;,\n  &quot;customerName&quot;: &quot;John Q. Public&quot;\n  &quot;deliveryAddress&quot;: &quot;1234 Elm St.&quot;,\n  &quot;productId&quot;: &quot;123&quot;,\n  &quot;quantity&quot;: 5\n}</code></pre></div>\n<p>The order refers to the product by its ID. If the client needs to display the product information in the context of the order, it makes two requests: one to get the order record, and one to get the details for the product specified on the order.</p>\n<p>You might try to improve this API in a couple ways. One would be to offer a way to retrieve the product details directly from the order number, so that you can make the two requests in parallel.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GET /orders/445566/product\n{\n  &quot;id&quot;: &quot;123&quot;,\n  &quot;name&quot;: &quot;Widget&quot;,\n  &quot;price&quot;: &quot;$10.00&quot;\n}</code></pre></div>\n<p>If you consistently need all the product information with the order, you might just decide to include the product information in the order resource:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GET /orders/445566\n{\n  &quot;id&quot;: &quot;445566&quot;,\n  &quot;customerName&quot;: &quot;John Q. Public&quot;\n  &quot;deliveryAddress&quot;: &quot;1234 Elm St.&quot;,\n  &quot;productId&quot;: &quot;123&quot;,\n  &quot;productName&quot;: &quot;Widget&quot;,\n  &quot;productPrice&quot;: &quot;$10.00&quot;\n  &quot;quantity&quot;: 5\n}</code></pre></div>\n<p>Now you’ve solved the issue of having to make multiple requests, but you’ve polluted the order object with properties from another resource, which makes it harder to use and evolve. You can fix this by keeping all product information under a single property:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GET /orders/445566\n{\n  &quot;id&quot;: &quot;445566&quot;,\n  &quot;customerName&quot;: &quot;John Q. Public&quot;\n  &quot;deliveryAddress&quot;: &quot;1234 Elm St.&quot;,\n  &quot;product&quot;: {\n    &quot;id&quot;: &quot;123&quot;,\n    &quot;name&quot;: &quot;Widget&quot;,\n    &quot;price&quot;: &quot;$10.00&quot;\n  }\n  &quot;quantity&quot;: 5\n}</code></pre></div>\n<p>That looks pretty good! It has the benefit that any code that was written to work with the <code class=\"language-text\">/products</code> response will also work with “product” property from <code class=\"language-text\">/orders</code>.</p>\n<p>The drawback of including the product information on the order is how it affects the backend. This may require a more expensive multi-table query with SQL, or a second query under NoSQL, or else a denormalized table that records product information with the order. It also increases the size of the response body, which can become a real problem as the REST API gets more mature and the response includes more information for different purposes.</p>\n<p>A slightly inelegant solution is to allow the request to flag whether it wants the product information:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GET /orders/445566?omitProduct=true\n{\n  &quot;id&quot;: &quot;445566&quot;,\n  &quot;customerName&quot;: &quot;John Q. Public&quot;\n  &quot;deliveryAddress&quot;: &quot;1234 Elm St.&quot;,\n  &quot;quantity&quot;: 5\n}</code></pre></div>\n<p>This is not very clean, but it does allow the backend to avoid doing the extra work when product information isn’t necessary, at the cost of increased code complexity. If you repeat this design struggle many times over the lifetime of your API, you may end up with a lot of flags for different properties.</p>\n<p>If you reach this point in your API design, then congratulations! You have partially re-invented GraphQL.</p>\n<h2>Enter GraphQL</h2>\n<p>Let’s see how a GraphQL API answers the same questions.</p>\n<p>You’d begin by creating types for products and orders. You don’t start the API by tying things together with foreign keys, as you did with REST. Instead, the order type contains a product field as we eventually decided on in the above example:</p>\n<div class=\"gatsby-highlight\" data-language=\"gql\"><pre class=\"language-gql\"><code class=\"language-gql\">type Product {\n  id: String!\n  name: String!\n  price: String!\n}\n\ntype Order {\n  id: String!\n  customerName: String!\n  deliveryAddress: String!\n  product: Product!\n  quantity: Int!\n}</code></pre></div>\n<p>You create query fields to get orders and products:</p>\n<div class=\"gatsby-highlight\" data-language=\"gql\"><pre class=\"language-gql\"><code class=\"language-gql\">type Query {\n  product(id: String!): Product\n  order(id: String!): Order\n}</code></pre></div>\n<p>If the client needs to get an order and the relevant product details, you only need a single query.</p>\n<p>Since the query contains an exact statement of all the properties that it expects, the service knows by design whether it needs to fetch product information. This allows you to write a backend that minimizes database and compute time.</p>\n<p>For example, suppose you want to know the customer name, delivery address, order quantity, product name, and product price:</p>\n<div class=\"gatsby-highlight\" data-language=\"gql\"><pre class=\"language-gql\"><code class=\"language-gql\">{\n  order(id: &quot;445566&quot;) {\n    customerName\n    deliveryAddress\n    quantity\n    product {\n      name\n      price\n    }\n  }\n}</code></pre></div>\n<p>This query would return only the requested properties:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  <span class=\"token string\">\"customerName\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"John Q. Public\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">\"deliveryAddress\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1234 Elm St.\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">\"quantity\"</span><span class=\"token operator\">:</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">\"product\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Widget\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"price\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"$10.00\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Making your GraphQL endpoint serverless</h2>\n<p>There are even deeper advantages to having a serverless GraphQL endpoint, which you can <a href=\"https://serverless.com/blog/running-scalable-reliable-graphql-endpoint-with-serverless/\">read more about here</a>.</p>\n<p>The tl;dr is that when you use GraphQL, you are relying on only one HTTP endpoint; and when you have one HTTP endpoint to connect all your clients to your backend services, you want that endpoint to be performant, reliable, and auto-scaling.</p>\n<h3>Building a GraphQL endpoint with the Serverless Framework</h3>\n<p>So, how do we build this with the <a href=\"https://serverless.com/framework/\">Serverless Framework</a>?</p>\n<p>We’re going to target AWS Lambda with Node 8 in this example, and the code should be easily adaptable to other FaaS providers. You can download the code for this example <a href=\"https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/graphql-blog.zip\">here</a>.</p>\n<p>Using the GraphQL reference implementation in JS, we can easily create our GraphQL schema from the type declarations.</p>\n<p>First import the utilities we need from the <code class=\"language-text\">graphql</code> library:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>\n  graphql<span class=\"token punctuation\">,</span>\n  buildSchema\n<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'graphql'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Now you can use GraphQL schema language to specify the schema:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> schema <span class=\"token operator\">=</span> <span class=\"token function\">buildSchema</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n  type Product {\n    id: String!\n    name: String!\n    price: String!\n  }\n\n  type Order {\n    id: String!\n    customerName: String!\n    deliveryAddress: String!\n    product: Product!\n    quantity: Int!\n  }\n\n  type Query {\n    product(id: String!): Product\n    order(id: String!): Order\n  }\n</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Next, we create resolvers so that queries can access our data. This is also where we make sure the resolver isn’t doing any more work than necessary. The <code class=\"language-text\">graphql</code> library is very flexible. Resolvers can exist for individual fields, and a resolver can either be a constant value, a function, a promise, or an asynchronous function. Functions have access to any arguments for the field via a single object parameter.</p>\n<p>We want the database record for the product information to be retrieved only when requested, so we make the resolver for that field a function:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> database <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./database'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> resolvers <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">product</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> id <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> database<span class=\"token punctuation\">.</span>products<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">order</span><span class=\"token operator\">:</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> id <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> order <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> database<span class=\"token punctuation\">.</span>orders<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>order<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>order<span class=\"token punctuation\">,</span>\n      <span class=\"token function-variable function\">product</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> database<span class=\"token punctuation\">.</span>products<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>productId<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The methods <code class=\"language-text\">database.products.get()</code> and <code class=\"language-text\">database.orders.get()</code> are both asynchronous functions, returning promises. The resolver for product simply calls through to the database. You do not need to worry about manually removing extraneous fields, since graphql-js does that for you.</p>\n<p>The resolver for order is more complex. It uses async/await syntax to fetch the order record before returning. This allows us to get the productId for use in the resolver for the product field. Since the resolver for the product field is a function, it won’t be invoked unless the product field is actually included in the query.</p>\n<p>All that remains is to create a handler for Lambda. Using the newer asynchronous syntax introduced by Node 8 for Lambda, this is very simple.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">query</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">graphql</span><span class=\"token punctuation\">(</span>schema<span class=\"token punctuation\">,</span> event<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">,</span> resolvers<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> statusCode<span class=\"token operator\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span> body<span class=\"token operator\">:</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Since all of the set-up logic for the GraphQL schema is outside of the handler, this will only be executed when Lambda needs to spin up a new instance to serve requests. To enable us to query by POST request, we have to include the following in <code class=\"language-text\">serverless.yml</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">service</span><span class=\"token punctuation\">:</span> my<span class=\"token punctuation\">-</span>api\n\n<span class=\"token key atrule\">provider</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> aws\n  <span class=\"token key atrule\">runtime</span><span class=\"token punctuation\">:</span> nodejs8.10\n\n<span class=\"token key atrule\">functions</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">hello</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">handler</span><span class=\"token punctuation\">:</span> handler.query\n    <span class=\"token key atrule\">events</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">http</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">path</span><span class=\"token punctuation\">:</span> /\n          <span class=\"token key atrule\">method</span><span class=\"token punctuation\">:</span> POST</code></pre></div>\n<p>That’s it. After a quick <code class=\"language-text\">sls deploy</code>, we can curl our new GraphQL endpoint to test the query:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">curl https://lsqgfkvs2i.execute-api.us-east-1.amazonaws.com/dev/ -d &#39;{\n  order(id: &quot;778899&quot;) {\n    customerName\n    deliveryAddress\n    quantity\n    product {\n      name\n      price\n    }\n  }\n}\n&#39;</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  <span class=\"token string\">\"order\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"customerName\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Stacey L. Civic\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"deliveryAddress\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"4321 Oak St.\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"quantity\"</span><span class=\"token operator\">:</span> <span class=\"token number\">32</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"product\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token string\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Gadget\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">\"price\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"$8.50\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Conclusion</h2>\n<p>You’ve now got a working GraphQL endpoint built with Serverless that scales automatically with increased traffic!</p>\n<p>In this example, we went with a single-Lambda approach. If you want infrastructural microservices, you can also use the flexibility of resolvers to have a primary Lambda that invokes other lambdas to resolve different query fields. If you want a more in-depth solution that uses GraphQL from top to bottom, you can use <a href=\"https://www.apollographql.com/docs/graphql-tools/schema-stitching.html\">schema stitching</a> to combine multiple GraphQL APIs into one.</p>\n<h3>Other Serverless + GraphQL resources</h3>\n<ul>\n<li><a href=\"https://serverless.com/blog/make-serverless-graphql-api-using-lambda-dynamodb/\">How to make a Serverless GraphQL API using Lambda and DynamoDB</a></li>\n<li><a href=\"https://serverless.com/blog/running-scalable-reliable-graphql-endpoint-with-serverless/\">Running a scalable &#x26; reliable GraphQL endpoint with Serverless</a></li>\n</ul>","frontmatter":{"title":"Efficient APIs with GraphQL and Serverless","date":"July 23, 2018","description":"When to use GraphQL, why it simplifies APIs, and how to do it Serverless-ly."}}},"pageContext":{"slug":"/posts/2018-07-23-efficient-apis-graphql-serverless/","previous":{"fields":{"slug":"/posts/2018-07-19-2018-serverless-community-survey-huge-growth-usage/"},"frontmatter":{"title":"2018 Serverless Community Survey: huge growth in serverless usage"}},"next":{"fields":{"slug":"/posts/2018-07-24-using-tensorflow-serverless-framework-deep-learning-image-recognition/"},"frontmatter":{"title":"Using TensorFlow and the Serverless Framework for deep learning and image recognition"}}}}}