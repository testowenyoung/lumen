{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/2018-04-04-dynamodb-backend-crudl-example-using-golang/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"eca2d3c9-b4f0-5489-8747-dfc35551f08b","excerpt":"This post is going to revolve around my adventure of building a working CRUDL serverless example in Golang. But first, some quick background about how and why I‚Ä¶","html":"<p>This post is going to revolve around my adventure of building a working CRUDL serverless example in Golang. But first, some quick background about how and why I got here.</p>\n<h2>Why I decided to experiment with Golang</h2>\n<p>Let‚Äôs just say‚Äîfor a software engineer, I‚Äôm kinda old. Not punchcard old, but audio-cassettes-as-storage old. It‚Äôs no surprise, then, that I‚Äôve used a lot of different languages: BASIC, Pascal, COBOL, assembler, C, C++, LISP, Smalltalk, Java, Javascript/Node, a little bit of Python/PHP, and an alphabet soup of .NET variants, to be exact.</p>\n<p>I did my <a href=\"https://fmlnerd.com/2016/08/16/30k-page-views-for-0-21-a-serverless-story/\">first Lambda project</a> in Java, because I didn‚Äôt want to have to get proficient in a new language while I was also learning a new platform. Even though the cold start issues didn‚Äôt plague me too much‚Äîall of my processing was backend batch data collection and massaging‚Äîit was pretty clear that Java had limitations for user-facing Lambda projects.</p>\n<p>So for <a href=\"http://functionrouter.com/\">my second Lambda project</a>, I used Node.js. Like many others, I had a love/hate relationship with Node. And while I loved how easy it was to find and use new packages with <em>npm</em>, I really couldn‚Äôt get past all the hoops I had to jump through to deal with callback hell. While Node is great for other tasks, it just doesn‚Äôt make sense to deal with concurrency in some form when building stateless functions that almost never need it.</p>\n<h3>And then came Golang</h3>\n<p>So when (1) AWS announced Golang support for Lambda, (2) my friends at the <a href=\"https://serverless.com/blog/framework-example-golang-lambda-support/\">Serverless Framework added support for it almost immediately</a>, and (3) some <a href=\"https://hackernoon.com/aws-lambda-go-vs-node-js-performance-benchmark-1c8898341982\">really good performance numbers for Golang Lambda functions</a> started to get published, I was intrigued.</p>\n<p>There‚Äôs not a ‚Äúbest language for serverless‚Äù winner yet, and given the limitations I ran into my first two legitimate tries, I thought it was worth my while to give Golang a test run.</p>\n<h2>Getting started</h2>\n<p>I started by working through <a href=\"https://serverless.com/blog/framework-example-golang-lambda-support/\">Maciej Winnicki‚Äôs initial Golang example</a>. After that, it seemed like a good next step was to build upon it, and produce a full CRUDL example that backed the functions with <a href=\"https://serverless.com/dynamodb/\">DynamoDB</a>.</p>\n<p>AWS had a nice <a href=\"https://github.com/awsdocs/aws-doc-sdk-examples/tree/master/go/example_code/dynamodb\">example of using Golang to interact with DynamoDB</a>, so all I did was repurpose that code so that it was called from within Lambda functions.</p>\n<h3>The application structure</h3>\n<p>The overview below will be general, but feel free to check out all the code on GitHub: <a href=\"https://github.com/nerdguru/go-sls-crud\"><code class=\"language-text\">go-sls-crud</code></a>.</p>\n<p>Here‚Äôs the basic structure.</p>\n<p>I put each function in its own <code class=\"language-text\">.go</code> file. Then, I centralized all the DynamoDB code in its own file, to isolate it in case I wanted to swap in a different data store later. That gave me a comfortable separation of powers: the function code dealt with the interaction with API Gateway objects, and the DAO file handled data.</p>\n<p>I‚Äôm not entirely convinced that I got the file structure right, but it‚Äôs functional, and this more complete example gave me a decent view into the good and bad of Golang.</p>\n<h2>Golang: the good and the bad</h2>\n<p>It was nice to have a compiler back after spending a few years with interpretive languages.</p>\n<p>I knew I‚Äôd make syntactical mistakes, and it was comforting to know that the compiler message gives you precision without the overhead of spinning up your whole binary first. I really like how the Golang compiler considers an import you don‚Äôt need to be an error, helping reduce the size of your eventual upload to Lambda.</p>\n<p>In order for Golang to scale for me, though, I‚Äôd have to be smarter about the structure of the <code class=\"language-text\">makefile</code>.  For noob level development like I was doing, having it compile every function every time was fine. But back in my C++ days, it was sure handy to have a <code class=\"language-text\">makefile</code> that was smart enough to only recompile things that changed.</p>\n<p>Productivity got a lot better when I switched from <a href=\"https://plugins.jetbrains.com/plugin/5047-go-language-golang-org-support-plugin\">IntelliJ‚Äôs Golang plugin</a> to <a href=\"https://atom.io/packages/go-plus\">Atom‚Äôs</a>. I found the linter to be a bit more powerful in Atom. If I were to continue with Golang, though, I‚Äôd spend some time figuring out how to get it to compile upon change using my <code class=\"language-text\">makefile</code> instead of its default install behavior.</p>\n<p>The hardest part of this early Golang learning curve was figuring out how to segment code into different files. And frankly, I‚Äôm still not certain I‚Äôm doing it right.</p>\n<p>I wanted to put all the DAO-like code that interacted with DynamoDB into one place so that it would be easier to swap it out for a different data store in the future. The path structure was difficult to follow, and I had trouble finding good examples. But I did eventually get it functional.</p>\n<h3>In sum?</h3>\n<p>Overall, I really liked how Golang minimized the amount of code I had to write. Once I overcame the path structure issue and got used to the syntax, progress came quickly.</p>\n<h2>Stuff I still need to learn, &#x26; what‚Äôs next</h2>\n<p>I stopped short of working in unit or system tests for this little CRUDL example, but those are the obvious next steps in the march towards a full-blown CI/CD toolchain example.</p>\n<p>As someone whose career started before test-driven development was a thing, I tend to favor system testing over unit testing; it tells you more about the production readiness of your code given the full interaction you get from all your components. If I were to continue with this project, I‚Äôd build some sort of endpoint testing suite (<a href=\"https://serverless.com/blog/cicd-for-serverless-part-1/\">like the one I started to build for Node over a year ago</a>).</p>\n<p>Alternatively, I was really impressed with <a href=\"https://serverless.com/blog/running-scalable-reliable-graphql-endpoint-with-serverless/\">Siddharth Gupta‚Äôs GraphQL example</a>, and think it would be fun to try to build a Golang, GraphQL, serverless CRUDL example (and win Buzzword Bingo in the process ü§ì).</p>\n<p>That would provide a nice foundation for the larger killer app example I think the serverless community is missing. Something like a serverless, GraphQL version of WordPress or Discourse. This would provide a bridge between an application most people understand, and a new way of architecting it with serverless‚Äîto both lower costs and make easier to iterate over.</p>\n<p>I‚Äôd love to hear some thoughts or suggestions on what might make sense, as the serverless revolution continues to gain ground.</p>","frontmatter":{"title":"A DynamoDB-backed CRUDL example using Golang","date":"April 05, 2018","description":"What a veteran coder learned about Golang by building a working CRUDL serverless example."}}},"pageContext":{"slug":"/posts/2018-04-04-dynamodb-backend-crudl-example-using-golang/","previous":{"fields":{"slug":"/posts/2018-04-03-guide-to-distributed-teams/"},"frontmatter":{"title":"Strategies for working with remote and distributed teams"}},"next":{"fields":{"slug":"/posts/2018-04-10-announcing-new-2018-serverless-champions/"},"frontmatter":{"title":"Introducing our first cohort of 2018 Serverless Champions"}}}}}